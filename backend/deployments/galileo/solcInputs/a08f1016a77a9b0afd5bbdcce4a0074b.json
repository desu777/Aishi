{
  "language": "Solidity",
  "sources": {
    "contracts/DreamAgentNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./interfaces/IERC7857.sol\";\nimport \"./interfaces/IERC7857DataVerifier.sol\";\n\n/// @title DreamAgentNFT - Personalized AI Dream Analysis Agents\n/// @notice Manages personalized dream agents with encrypted intelligence stored in 0G Storage\n/// @dev Enhanced version with agent naming, supply limit, and minting fee for testnet deployment\ncontract DreamAgentNFT is IERC7857 {\n    \n    // Data types for dream agents\n    string constant DREAM_PATTERNS = \"dream_patterns\";\n    string constant EMOTIONAL_PROFILE = \"emotional_profile\";\n    string constant AGENT_INTELLIGENCE = \"agent_intelligence\";\n    string constant PERSONALITY_DATA = \"personality_data\";\n    \n    // Maximum supply for testnet (cost control)\n    uint256 public constant MAX_AGENTS = 1000;\n    \n    // Minting fee: 0.1 OG (0.1 * 10^18 wei)\n    uint256 public constant MINTING_FEE = 0.1 ether;\n    \n    // Treasury address for collecting fees\n    address public immutable treasury;\n    \n    struct DreamAgent {\n        address owner;\n        string agentName;           // NEW: User-given name for personalization\n        uint256 createdAt;\n        uint256 lastUpdated;\n        string[] dataDescriptions;  // Types of data stored\n        bytes32[] dataHashes;       // 0G Storage hashes\n        address[] authorizedUsers;  // Authorized to use but not own\n        uint256 intelligenceLevel;  // Agent's learning progress\n        uint256 dreamCount;         // Number of dreams processed\n        uint256 conversationCount;  // NEW: Number of chat interactions\n    }\n    \n    // Contract state\n    mapping(uint256 => DreamAgent) public agents;\n    mapping(string => bool) public nameExists;  // NEW: Prevent duplicate names\n    uint256 public nextTokenId = 1;\n    uint256 public totalAgents = 0;\n    uint256 public totalFeesCollected = 0;      // Track total fees collected\n    \n    // Contract metadata\n    string public name = \"Dreamscape AI Agents\";\n    string public symbol = \"DREAM\";\n    \n    // Verifier for proof validation\n    IERC7857DataVerifier public immutable verifier;\n    \n    // Events\n    event Updated(uint256 indexed tokenId, bytes32[] oldDataHashes, bytes32[] newDataHashes);\n    event DreamProcessed(uint256 indexed tokenId, bytes32 dreamHash, uint256 newIntelligenceLevel);\n    event AgentEvolved(uint256 indexed tokenId, uint256 oldLevel, uint256 newLevel);\n    event AgentConversation(uint256 indexed tokenId, bytes32 conversationHash); // NEW: Chat tracking\n    event PersonalityEvolved(uint256 indexed tokenId, string trait, uint256 strength); // NEW: Personality tracking\n    event FeePaid(uint256 indexed tokenId, address indexed payer, uint256 amount); // NEW: Fee tracking\n    \n    constructor(address _verifier, address _treasury) {\n        require(_verifier != address(0), \"Verifier cannot be zero address\");\n        require(_treasury != address(0), \"Treasury cannot be zero address\");\n        verifier = IERC7857DataVerifier(_verifier);\n        treasury = _treasury;\n    }\n    \n    /// @notice Mint a new personalized dream agent for a user\n    /// @param proofs Ownership proofs for initial data\n    /// @param descriptions Data type descriptions\n    /// @param agentName User-given name for the agent\n    /// @param to Address to mint agent for\n    /// @return tokenId The newly minted agent token ID\n    function mint(\n        bytes[] calldata proofs,\n        string[] calldata descriptions,\n        string memory agentName,\n        address to\n    ) external payable returns (uint256 tokenId) {\n        require(to != address(0), \"Cannot mint to zero address\");\n        require(descriptions.length == proofs.length, \"Descriptions and proofs length mismatch\");\n        require(totalAgents < MAX_AGENTS, \"Maximum agents limit reached\");\n        require(bytes(agentName).length > 0 && bytes(agentName).length <= 32, \"Invalid agent name\");\n        require(!nameExists[agentName], \"Agent name already exists\");\n        require(msg.value >= MINTING_FEE, \"Insufficient payment for minting\");\n        \n        // Verify proofs\n        PreimageProofOutput[] memory proofOutputs = verifier.verifyPreimage(proofs);\n        bytes32[] memory dataHashes = new bytes32[](proofOutputs.length);\n        \n        for (uint256 i = 0; i < proofOutputs.length; i++) {\n            require(proofOutputs[i].isValid, \"Invalid proof\");\n            dataHashes[i] = proofOutputs[i].dataHash;\n        }\n        \n        // Reserve the name\n        nameExists[agentName] = true;\n        \n        // Create new personalized agent\n        tokenId = nextTokenId++;\n        agents[tokenId] = DreamAgent({\n            owner: to,\n            agentName: agentName,\n            createdAt: block.timestamp,\n            lastUpdated: block.timestamp,\n            dataDescriptions: descriptions,\n            dataHashes: dataHashes,\n            authorizedUsers: new address[](0),\n            intelligenceLevel: 1,\n            dreamCount: 0,\n            conversationCount: 0\n        });\n        \n        totalAgents++;\n        totalFeesCollected += MINTING_FEE;\n        \n        // Transfer minting fee to treasury\n        (bool success, ) = treasury.call{value: MINTING_FEE}(\"\");\n        require(success, \"Treasury payment failed\");\n        \n        // Refund excess payment\n        if (msg.value > MINTING_FEE) {\n            (bool refundSuccess, ) = msg.sender.call{value: msg.value - MINTING_FEE}(\"\");\n            require(refundSuccess, \"Refund failed\");\n        }\n        \n        emit Minted(tokenId, msg.sender, to, dataHashes, descriptions);\n        emit FeePaid(tokenId, msg.sender, MINTING_FEE);\n        \n        return tokenId;\n    }\n    \n    /// @notice Update agent data with new dream information\n    /// @param tokenId Agent to update\n    /// @param proofs New data proofs\n    function update(uint256 tokenId, bytes[] calldata proofs) external {\n        require(agents[tokenId].owner == msg.sender, \"Not agent owner\");\n        require(proofs.length == agents[tokenId].dataHashes.length, \"Proof count mismatch\");\n        \n        // Verify proofs\n        PreimageProofOutput[] memory proofOutputs = verifier.verifyPreimage(proofs);\n        bytes32[] memory oldDataHashes = agents[tokenId].dataHashes;\n        bytes32[] memory newDataHashes = new bytes32[](proofOutputs.length);\n        \n        for (uint256 i = 0; i < proofOutputs.length; i++) {\n            require(proofOutputs[i].isValid, \"Invalid proof\");\n            newDataHashes[i] = proofOutputs[i].dataHash;\n        }\n        \n        // Update agent\n        agents[tokenId].dataHashes = newDataHashes;\n        agents[tokenId].lastUpdated = block.timestamp;\n        agents[tokenId].dreamCount++;\n        \n        // Enhanced evolution logic: increase intelligence every 3 dreams (faster evolution)\n        if (agents[tokenId].dreamCount % 3 == 0) {\n            uint256 oldLevel = agents[tokenId].intelligenceLevel;\n            agents[tokenId].intelligenceLevel++;\n            emit AgentEvolved(tokenId, oldLevel, agents[tokenId].intelligenceLevel);\n            \n            // Emit personality evolution based on intelligence milestones\n            if (agents[tokenId].intelligenceLevel == 5) {\n                emit PersonalityEvolved(tokenId, \"analytical\", 75);\n            } else if (agents[tokenId].intelligenceLevel == 10) {\n                emit PersonalityEvolved(tokenId, \"empathetic\", 90);\n            }\n        }\n        \n        emit Updated(tokenId, oldDataHashes, newDataHashes);\n        emit DreamProcessed(tokenId, newDataHashes[0], agents[tokenId].intelligenceLevel);\n    }\n    \n    /// @notice Record a conversation with the agent (for personality development)\n    /// @param tokenId Agent that had conversation\n    /// @param conversationHash Hash of conversation data stored in 0G\n    function recordConversation(uint256 tokenId, bytes32 conversationHash) external {\n        require(agents[tokenId].owner == msg.sender, \"Not agent owner\");\n        \n        agents[tokenId].conversationCount++;\n        agents[tokenId].lastUpdated = block.timestamp;\n        \n        // Slight intelligence boost from conversations (1 point every 10 conversations)\n        if (agents[tokenId].conversationCount % 10 == 0) {\n            uint256 oldLevel = agents[tokenId].intelligenceLevel;\n            agents[tokenId].intelligenceLevel++;\n            emit AgentEvolved(tokenId, oldLevel, agents[tokenId].intelligenceLevel);\n        }\n        \n        emit AgentConversation(tokenId, conversationHash);\n    }\n    \n    /// @notice Transfer agent with intelligence to new owner\n    /// @param to New owner address\n    /// @param tokenId Agent to transfer\n    /// @param proofs Transfer validity proofs\n    function transfer(\n        address to,\n        uint256 tokenId,\n        bytes[] calldata proofs\n    ) external override {\n        require(to != address(0), \"Cannot transfer to zero address\");\n        require(agents[tokenId].owner == msg.sender, \"Not agent owner\");\n        \n        // Verify transfer proofs\n        TransferValidityProofOutput[] memory proofOutputs = verifier.verifyTransferValidity(proofs);\n        \n        for (uint256 i = 0; i < proofOutputs.length; i++) {\n            require(proofOutputs[i].isValid, \"Invalid transfer proof\");\n            require(proofOutputs[i].oldDataHash == agents[tokenId].dataHashes[i], \"Data hash mismatch\");\n        }\n        \n        // Update agent data hashes for new owner\n        bytes32[] memory newDataHashes = new bytes32[](proofOutputs.length);\n        bytes16[] memory sealedKeys = new bytes16[](proofOutputs.length);\n        \n        for (uint256 i = 0; i < proofOutputs.length; i++) {\n            newDataHashes[i] = proofOutputs[i].newDataHash;\n            sealedKeys[i] = proofOutputs[i].sealedKey;\n        }\n        \n        // Transfer ownership\n        address from = agents[tokenId].owner;\n        agents[tokenId].owner = to;\n        agents[tokenId].dataHashes = newDataHashes;\n        agents[tokenId].lastUpdated = block.timestamp;\n        \n        emit Transferred(tokenId, from, to);\n        emit PublishedSealedKey(to, tokenId, sealedKeys);\n    }\n    \n    /// @notice Clone agent (create copy with same intelligence and personality)\n    /// @param to Address to clone agent for\n    /// @param tokenId Agent to clone\n    /// @param newAgentName Name for the cloned agent\n    /// @param proofs Clone proofs\n    /// @return newTokenId The cloned agent token ID\n    function clone(\n        address to,\n        uint256 tokenId,\n        string memory newAgentName,\n        bytes[] calldata proofs\n    ) external payable returns (uint256 newTokenId) {\n        require(to != address(0), \"Cannot clone to zero address\");\n        require(agents[tokenId].owner == msg.sender, \"Not agent owner\");\n        require(totalAgents < MAX_AGENTS, \"Maximum agents limit reached\");\n        require(bytes(newAgentName).length > 0 && bytes(newAgentName).length <= 32, \"Invalid agent name\");\n        require(!nameExists[newAgentName], \"Agent name already exists\");\n        require(msg.value >= MINTING_FEE, \"Insufficient payment for cloning\");\n        \n        // Verify clone proofs (same as transfer proofs)\n        TransferValidityProofOutput[] memory proofOutputs = verifier.verifyTransferValidity(proofs);\n        \n        bytes32[] memory newDataHashes = new bytes32[](proofOutputs.length);\n        for (uint256 i = 0; i < proofOutputs.length; i++) {\n            require(proofOutputs[i].isValid, \"Invalid clone proof\");\n            newDataHashes[i] = proofOutputs[i].newDataHash;\n        }\n        \n        // Reserve the new name\n        nameExists[newAgentName] = true;\n        \n        // Create cloned agent with new name\n        newTokenId = nextTokenId++;\n        agents[newTokenId] = DreamAgent({\n            owner: to,\n            agentName: newAgentName,\n            createdAt: block.timestamp,\n            lastUpdated: block.timestamp,\n            dataDescriptions: agents[tokenId].dataDescriptions,\n            dataHashes: newDataHashes,\n            authorizedUsers: new address[](0),\n            intelligenceLevel: agents[tokenId].intelligenceLevel, // Same intelligence!\n            dreamCount: 0, // Reset dream count for new owner\n            conversationCount: 0 // Reset conversation count\n        });\n        \n        totalAgents++;\n        totalFeesCollected += MINTING_FEE;\n        \n        // Transfer cloning fee to treasury\n        (bool success, ) = treasury.call{value: MINTING_FEE}(\"\");\n        require(success, \"Treasury payment failed\");\n        \n        // Refund excess payment\n        if (msg.value > MINTING_FEE) {\n            (bool refundSuccess, ) = msg.sender.call{value: msg.value - MINTING_FEE}(\"\");\n            require(refundSuccess, \"Refund failed\");\n        }\n        \n        emit Cloned(tokenId, newTokenId, msg.sender, to);\n        emit Minted(newTokenId, msg.sender, to, newDataHashes, agents[tokenId].dataDescriptions);\n        emit FeePaid(newTokenId, msg.sender, MINTING_FEE);\n        \n        return newTokenId;\n    }\n    \n    /// @notice Authorize user to use agent (but not own)\n    /// @param tokenId Agent to authorize\n    /// @param user User to authorize\n    function authorizeUsage(uint256 tokenId, address user) external override {\n        require(agents[tokenId].owner == msg.sender, \"Not agent owner\");\n        require(user != address(0), \"Cannot authorize zero address\");\n        \n        agents[tokenId].authorizedUsers.push(user);\n        \n        emit AuthorizedUsage(tokenId, user);\n    }\n    \n    // View functions\n    function ownerOf(uint256 tokenId) external view override returns (address) {\n        return agents[tokenId].owner;\n    }\n    \n    function authorizedUsersOf(uint256 tokenId) external view override returns (address[] memory) {\n        return agents[tokenId].authorizedUsers;\n    }\n    \n    function getAgentInfo(uint256 tokenId) external view returns (\n        address owner,\n        string memory agentName,\n        uint256 intelligenceLevel,\n        uint256 dreamCount,\n        uint256 conversationCount,\n        uint256 lastUpdated,\n        string[] memory dataDescriptions\n    ) {\n        DreamAgent memory agent = agents[tokenId];\n        return (\n            agent.owner,\n            agent.agentName,\n            agent.intelligenceLevel,\n            agent.dreamCount,\n            agent.conversationCount,\n            agent.lastUpdated,\n            agent.dataDescriptions\n        );\n    }\n    \n    /// @notice Get remaining agent supply\n    function getRemainingSupply() external view returns (uint256) {\n        return MAX_AGENTS - totalAgents;\n    }\n    \n    /// @notice Check if agent name is available\n    function isNameAvailable(string memory agentName) external view returns (bool) {\n        return !nameExists[agentName];\n    }\n    \n    /// @notice Get minting fee in wei\n    function getMintingFee() external pure returns (uint256) {\n        return MINTING_FEE;\n    }\n    \n    /// @notice Get treasury address\n    function getTreasury() external view returns (address) {\n        return treasury;\n    }\n    \n    /// @notice Get total fees collected\n    function getTotalFeesCollected() external view returns (uint256) {\n        return totalFeesCollected;\n    }\n    \n    // Not implemented for testing (would require complex logic)\n    function transferPublic(address, uint256) external pure override {\n        revert(\"Public transfer not implemented\");\n    }\n    \n    function clonePublic(address, uint256) external payable override returns (uint256) {\n        revert(\"Public clone not implemented\");\n    }\n    \n    // Legacy mint function for compatibility\n    function mint(\n        bytes[] calldata /* proofs */,\n        string[] calldata /* descriptions */,\n        address /* to */\n    ) external payable returns (uint256) {\n        revert(\"Use mint with agentName parameter\");\n    }\n    \n    // Legacy clone function for compatibility  \n    function clone(\n        address /* to */,\n        uint256 /* tokenId */,\n        bytes[] calldata /* proofs */\n    ) external payable returns (uint256) {\n        revert(\"Use clone with newAgentName parameter\");\n    }\n} "
    },
    "contracts/interfaces/IERC7857.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport \"./IERC7857DataVerifier.sol\";\n\ninterface IERC7857 {\n    /// @dev This emits when a new functional NFT is minted\n    event Minted(\n        uint256 indexed _tokenId,\n        address indexed _creator,\n        address indexed _owner,\n        bytes32[] _dataHashes,\n        string[] _dataDescriptions\n    );\n\n    /// @dev This emits when a user is authorized to use the data\n    event AuthorizedUsage(uint256 indexed _tokenId, address indexed _user);\n\n    /// @dev This emits when data is transferred with ownership\n    event Transferred(\n        uint256 _tokenId,\n        address indexed _from,\n        address indexed _to\n    );\n\n    /// @dev This emits when data is cloned\n    event Cloned(\n        uint256 indexed _tokenId,\n        uint256 indexed _newTokenId,\n        address _from,\n        address _to\n    );\n\n    /// @dev This emits when a sealed key is published\n    event PublishedSealedKey(\n        address indexed _to,\n        uint256 indexed _tokenId,\n        bytes16[] _sealedKeys\n    );\n\n    /// @notice The verifier interface that this NFT uses\n    /// @return The address of the verifier contract\n    function verifier() external view returns (IERC7857DataVerifier);\n\n    /// @notice Mint new functional NFT with functional data ownership proof\n    /// @param _proofs Proof of data ownership\n    /// @param _dataDescriptions Descriptions of the data\n    /// @return _tokenId The ID of the newly minted token\n    /// @param _to The address to mint the token for, if _to is not set, the token will be minted for the caller\n    function mint(\n        bytes[] calldata _proofs,\n        string[] calldata _dataDescriptions,\n        address _to\n    ) external payable returns (uint256 _tokenId);\n\n    /// @notice Transfer data with ownership\n    /// @param _to Address to transfer data to\n    /// @param _tokenId The token to transfer data for\n    /// @param _proofs Proofs of data available for _to\n    function transfer(\n        address _to,\n        uint256 _tokenId,\n        bytes[] calldata _proofs\n    ) external;\n\n    /// @notice Clone data\n    /// @param _to Address to clone data to\n    /// @param _tokenId The token to clone data for\n    /// @param _proofs Proofs of data available for _to\n    /// @return _newTokenId The ID of the newly cloned token\n    function clone(\n        address _to,\n        uint256 _tokenId,\n        bytes[] calldata _proofs\n    ) external payable returns (uint256 _newTokenId);\n\n    /// @notice Transfer public data with ownership\n    /// @param _to Address to transfer data to\n    /// @param _tokenId The token to transfer data for\n    function transferPublic(address _to, uint256 _tokenId) external;\n\n    /// @notice Clone public data\n    /// @param _to Address to clone data to\n    /// @param _tokenId The token to clone data for\n    /// @return _newTokenId The ID of the newly cloned token\n    function clonePublic(\n        address _to,\n        uint256 _tokenId\n    ) external payable returns (uint256 _newTokenId);\n\n    /// @notice Add authorized user to group\n    /// @param _tokenId The token to add to group\n    function authorizeUsage(uint256 _tokenId, address _user) external;\n\n    /// @notice Get token owner\n    /// @param _tokenId The token identifier\n    /// @return The current owner of the token\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Get the authorized users of a token\n    /// @param _tokenId The token identifier\n    /// @return The current authorized users of the token\n    function authorizedUsersOf(\n        uint256 _tokenId\n    ) external view returns (address[] memory);\n} "
    },
    "contracts/interfaces/IERC7857DataVerifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nstruct PreimageProofOutput {\n    bytes32 dataHash;\n    bool isValid;\n}\n\nstruct TransferValidityProofOutput {\n    bytes32 oldDataHash;\n    bytes32 newDataHash;\n    bytes pubKey;\n    bytes16 sealedKey;\n    bool isValid;\n}\n\ninterface IERC7857DataVerifier {\n    /// @notice Verify preimage of data\n    /// @param proofs Proof of data ownership\n    /// @return Output of the preimage proof verification\n    function verifyPreimage(\n        bytes[] calldata proofs\n    ) external view returns (PreimageProofOutput[] memory);\n\n    /// @notice Verify data transfer validity\n    /// @param proofs Proof of data transfer validity\n    /// @return Output of the transfer validity proof verification\n    function verifyTransferValidity(\n        bytes[] calldata proofs\n    ) external view returns (TransferValidityProofOutput[] memory);\n} "
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted to signal this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/DreamscapeAgent.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/*\n * ────────────────────────────────────────────────────────────────────────────────\n *  IMPORTS\n * ────────────────────────────────────────────────────────────────────────────────\n *  Interfaces                                                  OpenZeppelin utils\n * ──────────────────────────────────────────────────────────── ──────────────────\n */\n\nimport \"./interfaces/IERC7857.sol\";               // ERC‑7857 base interface (iNFT standard)\nimport \"./interfaces/IERC7857DataVerifier.sol\";    // Optional: ZK‑proof verifier used at mint\nimport \"./interfaces/IPersonalityEvolution.sol\";   // Trait & evolution data‑model\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";  // protects against re‑entrancy\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";   // role‑based admin system\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";         // emergency stop\n\n/**\n * @title  DreamscapeAgent – iNFT with Hierarchical Memory & Personality Evolution\n * @notice Single‑per‑wallet autonomous agent that stores memories in a three‑layer\n *         hierarchy (daily → monthly → yearly) and evolves its personality from\n *         analysed dreams & conversations.\n *\n *         This contract is a *lean* revision: we removed unbounded on‑chain arrays\n *         of raw hashes to save gas and instead rely on off‑chain storage + a\n *         rotating «current» hash per period.  All public getters needed by dApp\n *         remain, but they now return an empty array and are marked *deprecated*.\n *\n *         The contract **still** complies with ERC‑7857 by preserving the original\n *         ABI of `mintAgent(...)`; callers MAY pass empty arrays when proofs are\n *         not needed.  Optional ZKP verification can be disabled by setting the\n *         `verifier` address to zero at deployment.\n *\n * @dev    Designed for direct deployment – no upgrade proxy included.  For\n *         upgradability, wrap this logic in a UUPS/Beacon proxy.\n */\ncontract DreamscapeAgent is\n    IERC7857,\n    IPersonalityEvolution,\n    ReentrancyGuard,\n    AccessControl,\n    Pausable\n{\n    /* ───────────────────────────────────────────────────────── CONSTANTS ───── */\n\n    uint256 public constant MAX_AGENTS   = 1_000;      // test‑net cap (adjust for main‑net)\n    uint256 public constant MINTING_FEE  = 0.1 ether;  // price per agent – sent to `treasury`\n\n    /* ───────────────────────────────────────────────────────── IMMUTABLES ──── */\n\n    address public immutable treasury;                  // fee recipient\n    IERC7857DataVerifier public immutable verifier;     // zero‑address ⇒ skip proof checks\n\n    /* ────────────────────────────────────────────────────────── ROLES ───────── */\n\n    bytes32 public constant ADMIN_ROLE    = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant VERIFIER_ROLE = keccak256(\"VERIFIER_ROLE\");\n    bytes32 public constant PAUSER_ROLE   = keccak256(\"PAUSER_ROLE\");\n\n    /* ────────────────────────────────────────────────────────── STORAGE ─────── */\n\n    /**\n     * @dev Core NFT data (no unbounded arrays – only counters & flags)\n     */\n    struct DreamAgent {\n        address  owner;            // current NFT owner\n        string   agentName;        // unique, user‑chosen name (max 32 bytes)\n        uint256  createdAt;        // block.timestamp at mint\n        uint256  lastUpdated;      // last on‑chain write (dream, convo, memory…)\n\n        // Access control\n        address[] authorizedUsers; // external EOAs permitted to operate the agent\n\n        // Intelligence & history counters\n        uint256  intelligenceLevel;\n        uint256  dreamCount;\n        uint256  conversationCount;\n\n        // Personality evolution meta\n        bool     personalityInitialized;\n        uint256  totalEvolutions;\n        uint256  lastEvolutionDate;\n        string[] achievedMilestones;\n    }\n    \n    /**\n     * @dev Milestone record per agent & name (e.g. \"memory_master\")\n     */\n    struct MilestoneData {\n        bool     achieved;\n        uint256  achievedAt;\n        uint8    traitValue; // value that unlocked the milestone (for UI)\n    }\n\n\n\n    /**\n     * @dev Rewards waiting for claim (set during monthly consolidation)\n     */\n    struct ConsolidationReward {\n        uint256 intelligenceBonus;\n        string  specialMilestone;\n        bool    yearlyReflection;\n    }\n\n    // ─── Main mappings ────────────────────────────────────────────────────────\n\n    mapping(uint256 => DreamAgent)                  public agents;             // tokenId → agent data\n    mapping(string  => bool)                        public nameExists;         // prevents duplicates\n    mapping(address => uint256)                     public ownerToTokenId;     // \"one agent per wallet\"\n\n    mapping(uint256 => PersonalityTraits)           public agentPersonalities; // traits struct from interface\n\n    mapping(uint256 => AgentMemory)                 public agentMemories;      // hierarchical storage\n    mapping(uint256 => ConsolidationReward)         public pendingRewards;     // waiting after consolidate\n    mapping(uint256 => uint256)                     public consolidationStreak;// consecutive months consolidated\n\n    mapping(uint256 => mapping(string => MilestoneData)) public milestones;    // tokenId → name → data\n    mapping(uint256 => string)                      public responseStyles;     // cached style for front‑end\n\n    // ─── Supply counters ─────────────────────────────────────────────────────\n\n    uint256 public nextTokenId   = 1; // starts at 1 for gas efficient existence checks\n    uint256 public totalAgents   = 0;\n    uint256 public totalFeesCollected = 0;\n\n    /* ───────────────────────────────────────────────────────── EVENTS ──────── */\n\n    // Core ERC‑7857\n    // ‑ Minted / Transferred / AuthorizedUsage inherited from interface\n\n    // Dream & personality\n    event PersonalityActivated  (uint256 indexed tokenId, PersonalityTraits traits, uint256 dreamCount);\n    event ResponseStyleUpdated  (uint256 indexed tokenId, string oldStyle, string newStyle);\n    event MilestoneUnlocked     (uint256 indexed tokenId, string milestone, uint8 value);\n    event AgentEvolved          (uint256 indexed tokenId, uint256 oldLevel, uint256 newLevel);\n    event DreamProcessed        (uint256 indexed tokenId, bytes32 dreamHash, uint256 intelligenceLevel);\n\n    // Hierarchical memory\n    event MemoryUpdated         (uint256 indexed tokenId, string memoryType, bytes32 newHash, bytes32 oldHash);\n    event ConsolidationNeeded   (uint256 indexed tokenId, uint8 month, uint16 year, string consolidationType);\n    event ConsolidationCompleted(uint256 indexed tokenId, string period, uint256 bonus, string specialReward);\n    event YearlyReflectionAvailable(uint256 indexed tokenId, uint16 year);\n    event MemoryMilestone       (uint256 indexed tokenId, string achievement, uint256 totalInteractions);\n\n    // Economics\n    event FeePaid               (uint256 indexed tokenId, address indexed payer, uint256 amount);\n\n    /* ──────────────────────────────────────────────────────── CONSTRUCTOR ─── */\n    \n    constructor(address _verifier, address _treasury) {\n        require(_treasury != address(0), \"treasury = zero addr\");\n        treasury  = _treasury;\n        verifier  = IERC7857DataVerifier(_verifier); // may be zero → proofs disabled\n\n        // grant all roles to deployer\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN_ROLE,          msg.sender);\n        _grantRole(VERIFIER_ROLE,       msg.sender);\n        _grantRole(PAUSER_ROLE,         msg.sender);\n    }\n\n    /* ──────────────────────────────────────────── MINT & INITIALISATION ───── */\n\n    /**\n     * @notice Mint a *blank‑slate* agent.  One per wallet.\n     * @param proofs        Optional ZK‑proof blobs (pass `[]` to skip)\n     * @param descriptions  Data descriptions parallel to `proofs`\n     * @param agentName     Unique display name (≤32 bytes)\n     * @param to            Recipient address (must NOT already own an agent)\n     */\n    function mintAgent(\n        bytes[]  calldata proofs,\n        string[] calldata descriptions,\n        string   memory   agentName,\n        address  to\n    ) external payable nonReentrant whenNotPaused returns (uint256 tokenId) {\n        /* ── basic checks ── */\n        require(to != address(0),                \"invalid to addr\");\n        require(ownerToTokenId[to] == 0,         \"wallet already has agent\");\n        require(totalAgents < MAX_AGENTS,        \"max supply reached\");\n        require(bytes(agentName).length > 0 && bytes(agentName).length <= 32, \"name length\");\n        require(!nameExists[agentName],          \"name exists\");\n        require(msg.value >= MINTING_FEE,        \"fee < 0.1 OG\");\n\n        /* ── optional proof verification ── */\n        bytes32[] memory dataHashes;\n        if (address(verifier) != address(0)) {\n            require(descriptions.length == proofs.length, \"len mismatch\");\n            PreimageProofOutput[] memory outs = verifier.verifyPreimage(proofs);\n            dataHashes = new bytes32[](outs.length);\n            for (uint256 i = 0; i < outs.length; ++i) {\n                require(outs[i].isValid, \"invalid proof\");\n                dataHashes[i] = outs[i].dataHash;\n            }\n        }\n\n        /* ── name reservation ── */\n        nameExists[agentName] = true;\n        \n        /* ── create agent ── */\n        tokenId = nextTokenId++;\n        ownerToTokenId[to] = tokenId;\n\n        agents[tokenId] = DreamAgent({\n            owner:                   to,\n            agentName:               agentName,\n            createdAt:               block.timestamp,\n            lastUpdated:             block.timestamp,\n            authorizedUsers:         new address[](0),\n            intelligenceLevel:       1,\n            dreamCount:              0,\n            conversationCount:       0,\n            personalityInitialized:  true,  // ✅ Inicjalizujemy od razu\n            totalEvolutions:         0,\n            lastEvolutionDate:       block.timestamp,\n            achievedMilestones:      new string[](0)\n        });\n\n        /* ── initialized personality (neutral starting point) ── */\n        PersonalityTraits memory initialTraits = PersonalityTraits({\n            creativity:     50,\n            analytical:     50,\n            empathy:        50,\n            intuition:      50,\n            resilience:     50,\n            curiosity:      50,\n            dominantMood:   \"neutral\",\n            lastDreamDate:  0,\n            uniqueFeatures: new UniqueFeature[](0)\n        });\n        agentPersonalities[tokenId] = initialTraits;\n        responseStyles[tokenId] = \"neutral\";\n        \n        /* ── emit personality activation ── */\n        emit PersonalityActivated(tokenId, initialTraits, 0);\n        \n        /* ── memory initialisation ── */\n        agentMemories[tokenId] = AgentMemory({\n            memoryCoreHash:        bytes32(0),\n            currentDreamDailyHash: bytes32(0),\n            currentConvDailyHash:  bytes32(0),\n            lastDreamMonthlyHash:  bytes32(0),\n            lastConvMonthlyHash:   bytes32(0),\n            lastConsolidation:     block.timestamp,\n            currentMonth:  _currentMonth(),\n            currentYear:   _currentYear()\n        });\n\n        /* ── economics ── */\n        totalAgents          += 1;\n        totalFeesCollected   += MINTING_FEE;\n\n        (bool sent, ) = treasury.call{value: MINTING_FEE}(\"\");\n        require(sent, \"treasury transfer failed\");\n        if (msg.value > MINTING_FEE) {\n            (bool refund, ) = msg.sender.call{value: msg.value - MINTING_FEE}(\"\");\n            require(refund, \"refund failed\");\n        }\n        \n        /* ── events ── */\n        emit Minted(tokenId, msg.sender, to, dataHashes, descriptions);\n        emit FeePaid(tokenId, msg.sender, MINTING_FEE);\n    }\n\n    /* ───────────────────────────────────────────────── PERSONALITY LOGIC ─── */\n\n    /**\n     * @notice Called once per «dream»; every 5th dream triggers evolution.\n     *         Also updates hierarchical memory with dream hash.\n     * @dev    ZK‑verified dream *content* lives off‑chain; contract stores only\n     *         hash + counters to keep gas low.\n     */\n    function processDailyDream(\n        uint256            tokenId,\n        bytes32            dreamHash,\n        PersonalityImpact  calldata impact\n    ) external override whenNotPaused onlyOwnerOrAuthorized(tokenId) {\n        _validatePersonalityImpact(impact);\n\n        DreamAgent storage agent = agents[tokenId];\n        PersonalityTraits storage traits = agentPersonalities[tokenId];\n\n        // cooldown – first dream is allowed instantly; afterwards 24h gap\n        // COMMENTED FOR TESTING - REMOVE COOLDOWN\n        /*\n        require(\n            traits.lastDreamDate == 0 || block.timestamp >= traits.lastDreamDate + 24 hours,\n            \"cooldown <24h\"\n        );\n        */\n\n        // update counters\n        agent.dreamCount      += 1;\n        agent.lastUpdated      = block.timestamp;\n        traits.lastDreamDate   = block.timestamp;\n\n        /* ── 1. update hierarchical memory ── */\n        AgentMemory storage mem = agentMemories[tokenId];\n        bytes32 old = mem.currentDreamDailyHash;\n        mem.currentDreamDailyHash = dreamHash;\n        emit MemoryUpdated(tokenId, \"dream_daily\", dreamHash, old);\n        _checkMonthChange(tokenId);\n\n        /* ── 2. incremental intelligence boost every 3 dreams ── */\n        if (agent.dreamCount % 3 == 0) {\n            uint256 oldLvl = agent.intelligenceLevel;\n            agent.intelligenceLevel += 1;\n            emit AgentEvolved(tokenId, oldLvl, agent.intelligenceLevel);\n        }\n\n        /* ── 3. personality evolution every 5 dreams ── */\n        if (agent.dreamCount % 5 == 0) {\n            PersonalityTraits memory before = traits;\n\n            traits.creativity  = _updateTrait(traits.creativity,  impact.creativityChange);\n            traits.analytical  = _updateTrait(traits.analytical,  impact.analyticalChange);\n            traits.empathy     = _updateTrait(traits.empathy,     impact.empathyChange);\n            traits.intuition   = _updateTrait(traits.intuition,   impact.intuitionChange);\n            traits.resilience  = _updateTrait(traits.resilience,  impact.resilienceChange);\n            traits.curiosity   = _updateTrait(traits.curiosity,   impact.curiosityChange);\n            traits.dominantMood = impact.moodShift;\n\n            // ── AI-generated unique features ──\n            if (impact.newFeatures.length > 0) {\n                require(impact.newFeatures.length <= 2, \"max 2 features per dream\");\n                \n                for (uint256 i = 0; i < impact.newFeatures.length; i++) {\n                    require(bytes(impact.newFeatures[i].name).length > 0, \"feature name empty\");\n                    require(impact.newFeatures[i].intensity > 0 && impact.newFeatures[i].intensity <= 100, \"invalid intensity\");\n                    \n                    // Add timestamp and push to agent's unique features\n                    UniqueFeature memory newFeature = impact.newFeatures[i];\n                    newFeature.addedAt = block.timestamp;\n                    traits.uniqueFeatures.push(newFeature);\n                }\n                \n                emit UniqueFeaturesAdded(tokenId, impact.newFeatures, traits.uniqueFeatures.length);\n            }\n\n            agent.totalEvolutions += 1;\n            agent.lastEvolutionDate = block.timestamp;\n\n            _checkPersonalityMilestones(tokenId, before, traits);\n            _updateResponseStyle(tokenId);\n\n            emit PersonalityEvolved(tokenId, dreamHash, traits, impact);\n        }\n\n        emit DreamProcessed(tokenId, dreamHash, agent.intelligenceLevel);\n    }\n\n    /**\n     * @notice Lightweight conversation recording; boosts intelligence every 10th convo.\n     *         Also updates hierarchical memory with conversation hash.\n     */\n    function recordConversation(\n        uint256    tokenId,\n        bytes32    conversationHash,\n        ContextType contextType\n    ) external override whenNotPaused onlyOwnerOrAuthorized(tokenId) {\n        DreamAgent storage agent = agents[tokenId];\n\n        agent.conversationCount += 1;\n        agent.lastUpdated        = block.timestamp;\n\n        /* ── 1. update hierarchical memory ── */\n        AgentMemory storage mem = agentMemories[tokenId];\n        bytes32 old = mem.currentConvDailyHash;\n        mem.currentConvDailyHash = conversationHash;\n        emit MemoryUpdated(tokenId, \"conversation_daily\", conversationHash, old);\n        _checkMonthChange(tokenId);\n\n        /* ── 2. intelligence boost every 10th conversation ── */\n        if (agent.conversationCount % 10 == 0) {\n            uint256 oldLvl = agent.intelligenceLevel;\n            agent.intelligenceLevel += 1;\n            emit AgentEvolved(tokenId, oldLvl, agent.intelligenceLevel);\n        }\n\n        emit AgentConversation(tokenId, conversationHash, contextType, agent.conversationCount);\n    }\n\n    /* ─────────────────────────────────────────── HIERARCHICAL MEMORY ───────── */\n\n\n\n    /**\n     * @notice User‑driven monthly consolidation.  Merges daily files off‑chain and\n     *         stores the finalised month hash on‑chain, rewarding the agent.\n     */\n    function consolidateMonth(\n        uint256 tokenId,\n        bytes32 dreamMonthlyHash,\n        bytes32 convMonthlyHash,\n        uint8   month,\n        uint16  year\n    ) external whenNotPaused onlyOwnerOrAuthorized(tokenId) {\n        require(month >= 1 && month <= 12, \"invalid month\");\n        require(year  >= 2024 && year  <= 2100, \"invalid year\");\n\n        AgentMemory storage mem = agentMemories[tokenId];\n        require(mem.currentMonth != month || mem.currentYear != year, \"still current month\");\n\n        mem.lastDreamMonthlyHash = dreamMonthlyHash;\n        mem.lastConvMonthlyHash  = convMonthlyHash;\n        mem.lastConsolidation    = block.timestamp;\n\n        // streak logic\n        consolidationStreak[tokenId] += 1;\n        uint256 bonus = _calculateConsolidationBonus(tokenId);\n        string memory special = _checkConsolidationMilestones(tokenId);\n\n        DreamAgent storage agent = agents[tokenId];\n        uint256 oldLvl = agent.intelligenceLevel;\n        agent.intelligenceLevel += bonus;\n\n        emit ConsolidationCompleted(tokenId, _formatPeriod(month, year), bonus, special);\n        emit AgentEvolved(tokenId, oldLvl, agent.intelligenceLevel);\n\n        // yearly reflection flag\n        if (month == 12) {\n            pendingRewards[tokenId].yearlyReflection = true;\n            emit YearlyReflectionAvailable(tokenId, year);\n        }\n    }\n\n    /**\n     * @notice Stores the yearly «memory core» hash and grants bonus INT.\n     */\n    function updateMemoryCore(uint256 tokenId, bytes32 newHash)\n        external whenNotPaused onlyOwnerOrAuthorized(tokenId)\n    {\n        AgentMemory storage mem = agentMemories[tokenId];\n        bytes32 old = mem.memoryCoreHash;\n        mem.memoryCoreHash = newHash;\n        emit MemoryUpdated(tokenId, \"memory_core\", newHash, old);\n\n        if (pendingRewards[tokenId].yearlyReflection) {\n            pendingRewards[tokenId].yearlyReflection = false;\n            DreamAgent storage agent = agents[tokenId];\n            uint256 oldLvl = agent.intelligenceLevel;\n            agent.intelligenceLevel += 5;\n            emit AgentEvolved(tokenId, oldLvl, agent.intelligenceLevel);\n        }\n    }\n\n    /* ───────────────────────────────────────────────── VIEW HELPERS ────────── */\n\n    function getPersonalityTraits(uint256 tokenId)\n        external view override returns (PersonalityTraits memory) {\n        require(agents[tokenId].owner != address(0), \"agent !exist\");\n        return agentPersonalities[tokenId];\n    }\n\n    /**\n     * @notice Get memory access level based on intelligence\n     * @param tokenId Agent to check\n     * @return monthsAccessible Number of months accessible \n     * @return memoryDepth Human-readable description\n     */\n    function getMemoryAccess(uint256 tokenId) external view returns (\n        uint256 monthsAccessible,\n        string memory memoryDepth\n    ) {\n        require(agents[tokenId].owner != address(0), \"agent !exist\");\n        uint256 intelligence = agents[tokenId].intelligenceLevel;\n        \n        if (intelligence >= 60) {\n            monthsAccessible = 60;\n            memoryDepth = \"5 years complete archive\";\n        } else if (intelligence >= 48) {\n            monthsAccessible = 48;\n            memoryDepth = \"4 years\";\n        } else if (intelligence >= 36) {\n            monthsAccessible = 36;\n            memoryDepth = \"3 years\";\n        } else if (intelligence >= 24) {\n            monthsAccessible = 24;\n            memoryDepth = \"2 years\";\n        } else if (intelligence >= 12) {\n            monthsAccessible = 12;\n            memoryDepth = \"annual\";\n        } else if (intelligence >= 6) {\n            monthsAccessible = 6;\n            memoryDepth = \"half-year\";\n        } else if (intelligence >= 3) {\n            monthsAccessible = 3;\n            memoryDepth = \"quarterly\";\n        } else {\n            monthsAccessible = 1;\n            memoryDepth = \"current month only\";\n        }\n    }\n\n    /**\n     * @notice Get agent's hierarchical memory structure\n     * @param tokenId Agent to query\n     * @return memory Current memory structure\n     */\n    function getAgentMemory(uint256 tokenId) external view returns (AgentMemory memory) {\n        require(agents[tokenId].owner != address(0), \"agent !exist\");\n        return agentMemories[tokenId];\n    }\n\n    /**\n     * @notice Check if consolidation is needed\n     * @param tokenId Agent to check\n     * @return isNeeded True if month has changed since last consolidation\n     * @return currentMonth Current month\n     * @return currentYear Current year\n     */\n    function needsConsolidation(uint256 tokenId) external view returns (\n        bool isNeeded,\n        uint8 currentMonth,\n        uint16 currentYear\n    ) {\n        require(agents[tokenId].owner != address(0), \"agent !exist\");\n        AgentMemory memory mem = agentMemories[tokenId];\n        currentMonth = _currentMonth();\n        currentYear = _currentYear();\n        isNeeded = (mem.currentMonth != currentMonth || mem.currentYear != currentYear);\n    }\n\n    /**\n     * @notice Get consolidation reward preview\n     * @param tokenId Agent to check\n     * @return baseReward Base intelligence reward\n     * @return streakBonus Bonus from consolidation streak\n     * @return earlyBirdBonus Bonus for early consolidation\n     * @return totalReward Total intelligence reward\n     */\n    function getConsolidationReward(uint256 tokenId) external view returns (\n        uint256 baseReward,\n        uint256 streakBonus,\n        uint256 earlyBirdBonus,\n        uint256 totalReward\n    ) {\n        require(agents[tokenId].owner != address(0), \"agent !exist\");\n        baseReward = 2;\n        \n        uint256 streak = consolidationStreak[tokenId];\n        if (streak >= 12) streakBonus = 5;\n        else if (streak >= 6) streakBonus = 3;\n        else if (streak >= 3) streakBonus = 1;\n        else streakBonus = 0;\n        \n        AgentMemory memory mem = agentMemories[tokenId];\n        if (block.timestamp <= mem.lastConsolidation + 3 days) {\n            earlyBirdBonus = 1;\n        } else {\n            earlyBirdBonus = 0;\n        }\n        \n        totalReward = baseReward + streakBonus + earlyBirdBonus;\n    }\n\n    /**\n     * @notice Check if agent can process dream today (24h cooldown)\n     * @param tokenId Agent to check\n     * @return canProcess True if agent can process a dream today\n     */\n    function canProcessDreamToday(uint256 tokenId) external view returns (bool canProcess) {\n        require(agents[tokenId].owner != address(0), \"agent !exist\");\n        // COMMENTED FOR TESTING - ALWAYS RETURN TRUE\n        // PersonalityTraits memory t = agentPersonalities[tokenId];\n        // return t.lastDreamDate == 0 || block.timestamp >= t.lastDreamDate + 24 hours;\n        return true; // TESTING: No cooldown\n    }\n\n\n\n    function getEvolutionStats(uint256 tokenId)\n        external view override returns (uint256 totalEvolutions, uint256 evolutionRate, uint256 lastEvolution)\n    {\n        DreamAgent memory a = agents[tokenId];\n        totalEvolutions = a.totalEvolutions;\n        lastEvolution   = a.lastEvolutionDate;\n        uint256 daysSinceCreation = (block.timestamp - a.createdAt) / 1 days;\n        evolutionRate = daysSinceCreation == 0 ? 0 : (totalEvolutions * 100) / daysSinceCreation;\n    }\n\n    function hasMilestone(uint256 tokenId, string calldata milestoneName)\n        external view override returns (bool achieved, uint256 at)\n    {\n        MilestoneData memory m = milestones[tokenId][milestoneName];\n        return (m.achieved, m.achievedAt);\n    }\n\n    /// @notice Get agent's unique AI-generated features\n    /// @param tokenId Agent to query\n    /// @return features Array of unique features\n    function getUniqueFeatures(uint256 tokenId) \n        external view override returns (UniqueFeature[] memory features)\n    {\n        require(agents[tokenId].owner != address(0), \"agent !exist\");\n        return agentPersonalities[tokenId].uniqueFeatures;\n    }\n\n\n    /* ─────────────────────────────────────────── ERC‑7857 TRANSFER ETC. ───── */\n    \n    function ownerOf(uint256 tokenId) external view override returns (address) {\n        return agents[tokenId].owner;\n    }\n    \n    function authorizedUsersOf(uint256 tokenId) external view override returns (address[] memory) {\n        return agents[tokenId].authorizedUsers;\n    }\n    \n    function authorizeUsage(uint256 tokenId, address user)\n        external override onlyOwnerOrAdmin(tokenId) {\n        require(user != address(0), \"zero user\");\n        agents[tokenId].authorizedUsers.push(user);\n        emit AuthorizedUsage(tokenId, user);\n    }\n    \n    function transfer(address to, uint256 tokenId, bytes[] calldata) external override onlyOwnerOrAdmin(tokenId) {\n        require(to != address(0), \"to = zero\");\n        require(ownerToTokenId[to] == 0, \"to already owns agent\");\n        \n        address from = agents[tokenId].owner;\n        ownerToTokenId[from] = 0;\n        ownerToTokenId[to]   = tokenId;\n        agents[tokenId].owner = to;\n        agents[tokenId].lastUpdated = block.timestamp;\n        emit Transferred(tokenId, from, to);\n    }\n    \n    /* ─────────────────────────────────────────────── OTHER VIEWS ──────────── */\n\n    function totalSupply() external view returns (uint256) { return totalAgents; }\n    \n    function balanceOf(address owner) external view returns (uint256) {\n        require(owner != address(0), \"zero owner\");\n        return ownerToTokenId[owner] == 0 ? 0 : 1;\n    }\n\n    /**\n     * @notice Returns the name of the contract collection\n     * @return The contract name \"DreamscapeAgent\"\n     */\n    function name() external pure returns (string memory) {\n        return \"DreamscapeAgent\";\n    }\n\n    /**\n     * @notice Returns the symbol of the contract collection  \n     * @return The contract symbol \"DREAM\"\n     */\n    function symbol() external pure returns (string memory) {\n        return \"DREAM\";\n    }\n\n    function supportsInterface(bytes4 id) public view override returns (bool) {\n        return\n            id == type(IERC721).interfaceId ||\n            id == type(IERC721Metadata).interfaceId ||\n            id == type(IERC7857).interfaceId ||\n            super.supportsInterface(id);\n    }\n\n    /* ───────────────────────────────────────────── ADMIN / EMERGENCY ──────── */\n\n    function pause() external onlyRole(PAUSER_ROLE) { _pause(); }\n    function unpause() external onlyRole(PAUSER_ROLE) { _unpause(); }\n    \n    function emergencyAuthorizeUser(uint256 tokenId, address user) external onlyRole(ADMIN_ROLE) {\n        require(user != address(0), \"zero user\");\n        agents[tokenId].authorizedUsers.push(user);\n        emit AuthorizedUsage(tokenId, user);\n    }\n    \n    function emergencyTransfer(uint256 tokenId, address to) external onlyRole(ADMIN_ROLE) {\n        require(to != address(0), \"to = zero\");\n        require(ownerToTokenId[to] == 0, \"to already owns\");\n        \n        address from = agents[tokenId].owner;\n        ownerToTokenId[from] = 0;\n        ownerToTokenId[to]   = tokenId;\n        agents[tokenId].owner = to;\n        agents[tokenId].lastUpdated = block.timestamp;\n        emit Transferred(tokenId, from, to);\n    }\n    \n    /* ──────────────────────────────────────────── MODIFIERS & HELPERS ─────── */\n\n    modifier onlyOwnerOrAuthorized(uint256 tokenId) {\n        require(\n            agents[tokenId].owner == msg.sender ||\n            hasRole(ADMIN_ROLE, msg.sender)     ||\n            _isAuthorizedUser(tokenId, msg.sender),\n            \"not authorised\"\n        );\n        _;\n    }\n\n    modifier onlyOwnerOrAdmin(uint256 tokenId) {\n        require(\n            agents[tokenId].owner == msg.sender || hasRole(ADMIN_ROLE, msg.sender),\n            \"owner/admin only\"\n        );\n        _;\n    }\n\n    function _isAuthorizedUser(uint256 tokenId, address user) internal view returns (bool) {\n        address[] memory list = agents[tokenId].authorizedUsers;\n        for (uint256 i = 0; i < list.length; ++i) if (list[i] == user) return true;\n        return false;\n    }\n\n    /* ───────────────────────────────────────── PRIVATE: PERSONALITY ──────── */\n\n    function _validatePersonalityImpact(PersonalityImpact calldata i) internal pure {\n        require(i.evolutionWeight > 0 && i.evolutionWeight <= 100, \"weight out of range\");\n        require(bytes(i.moodShift).length > 0,                   \"empty mood\");\n        require(_inRange(i.creativityChange)   && _inRange(i.analyticalChange) &&\n                _inRange(i.empathyChange)      && _inRange(i.intuitionChange)  &&\n                _inRange(i.resilienceChange)   && _inRange(i.curiosityChange),  unicode\"Δ out of range\");\n        \n        // Validate unique features (max 2 per dream)\n        require(i.newFeatures.length <= 2, \"max 2 features per impact\");\n        for (uint256 j = 0; j < i.newFeatures.length; j++) {\n            require(bytes(i.newFeatures[j].name).length > 0, \"feature name empty\");\n            require(bytes(i.newFeatures[j].description).length > 0, \"feature description empty\");\n            require(i.newFeatures[j].intensity > 0 && i.newFeatures[j].intensity <= 100, \"feature intensity out of range\");\n        }\n    }\n    function _inRange(int8 x) private pure returns (bool) { return x >= -10 && x <= 10; }\n\n    function _updateTrait(uint8 current, int8 delta) internal pure returns (uint8) {\n        int256 temp = int256(uint256(current)) + int256(delta);\n        if (temp < 0)   temp = 0;\n        if (temp > 100) temp = 100;\n        return uint8(uint256(temp));\n    }\n\n    function _updateResponseStyle(uint256 tokenId) internal {\n        PersonalityTraits memory t = agentPersonalities[tokenId];\n        string memory style;\n        if (t.empathy > 70 && t.creativity > 60)      style = \"empathetic_creative\";\n        else if (t.empathy > 70)                      style = \"empathetic\";\n        else if (t.creativity > 70)                   style = \"creative\";\n        else if (t.analytical > 70)                   style = \"analytical\";\n        else if (t.intuition > 70)                    style = \"intuitive\";\n        else if (t.resilience > 70)                   style = \"resilient\";\n        else if (t.curiosity > 70)                    style = \"curious\";\n        else                                         style = \"balanced\";\n\n        if (keccak256(bytes(responseStyles[tokenId])) != keccak256(bytes(style))) {\n            string memory old = responseStyles[tokenId];\n            responseStyles[tokenId] = style;\n            emit ResponseStyleUpdated(tokenId, old, style);\n            string[] memory dom = _getDominantTraitNames(tokenId);\n            emit ResponseStyleEvolved(tokenId, style, dom);\n        }\n    }\n\n    function _getDominantTraitNames(uint256 tokenId) internal view returns (string[] memory names) {\n        PersonalityTraits memory p = agentPersonalities[tokenId];\n        uint8[6] memory v = [p.creativity, p.analytical, p.empathy, p.intuition, p.resilience, p.curiosity];\n        string[6] memory n = [\"creativity\",\"analytical\",\"empathy\",\"intuition\",\"resilience\",\"curiosity\"];\n        names = new string[](3);\n        for (uint256 k; k < 3; ++k) {\n            uint256 m = 0;\n            for (uint256 j = 1; j < 6; ++j) if (v[j] > v[m]) m = j;\n            names[k] = n[m];\n            v[m] = 0; // prevent reuse\n        }\n    }\n\n    function _checkPersonalityMilestones(uint256 tokenId, PersonalityTraits memory old, PersonalityTraits memory nu) internal {\n        if (old.empathy  < 85 && nu.empathy  >= 85) _unlockMilestone(tokenId, \"empathy_master\",  nu.empathy);\n        if (old.creativity< 90 && nu.creativity>= 90) _unlockMilestone(tokenId, \"creative_genius\",nu.creativity);\n        if (old.analytical< 90 && nu.analytical>= 90) _unlockMilestone(tokenId, \"logic_lord\",    nu.analytical);\n        if (old.intuition< 90 && nu.intuition>= 90) _unlockMilestone(tokenId, \"spiritual_guide\",nu.intuition);\n        bool balanced = nu.creativity>60 && nu.analytical>60 && nu.empathy>60 && nu.intuition>60 && nu.resilience>60 && nu.curiosity>60;\n        if (balanced && !milestones[tokenId][\"balanced_soul\"].achieved) _unlockMilestone(tokenId, \"balanced_soul\", 60);\n    }\n\n    function _unlockMilestone(uint256 id, string memory milestoneName, uint8 val) internal {\n        milestones[id][milestoneName] = MilestoneData(true, block.timestamp, val);\n        agents[id].achievedMilestones.push(milestoneName);\n        emit PersonalityMilestone(id, milestoneName, val, \"\");\n        emit MilestoneUnlocked(id, milestoneName, val);\n    }\n\n    /* ─────────────────────────────────────────── PRIVATE: MEMORY HELPERS ──── */\n\n    function _checkMonthChange(uint256 id) internal {\n        AgentMemory storage m = agentMemories[id];\n        uint8 cm = _currentMonth();\n        uint16 cy = _currentYear();\n        if (m.currentMonth == 0) { // first time – initialise\n            m.currentMonth = cm; m.currentYear = cy; return;\n        }\n        if (m.currentMonth != cm || m.currentYear != cy) {\n            emit ConsolidationNeeded(id, m.currentMonth, m.currentYear, \"monthly\");\n            m.currentMonth = cm; m.currentYear = cy;\n            m.currentDreamDailyHash = bytes32(0);\n            m.currentConvDailyHash  = bytes32(0);\n            if (block.timestamp > m.lastConsolidation + 37 days) consolidationStreak[id] = 0; // lose streak\n        }\n    }\n\n    function _calculateConsolidationBonus(uint256 id) internal view returns (uint256 b) {\n        uint256 st = consolidationStreak[id];\n        b = 2;\n        if      (st >= 12) b += 5;\n        else if (st >= 6)  b += 3;\n        else if (st >= 3)  b += 1;\n        AgentMemory storage m = agentMemories[id];\n        if (block.timestamp <= m.lastConsolidation + 3 days) b += 1; // early bird\n    }\n\n    function _checkConsolidationMilestones(uint256 id) internal returns (string memory) {\n        uint256 st = consolidationStreak[id];\n        if (st == 3)  { _unlockMilestone(id, \"memory_keeper\", 3);   return \"Memory Keeper\"; }\n        if (st == 6)  { _unlockMilestone(id, \"memory_guardian\", 6); return \"Memory Guardian\"; }\n        if (st == 12) { _unlockMilestone(id, \"memory_master\",12);   return \"Memory Master\"; }\n        if (st == 24) { _unlockMilestone(id, \"eternal_memory\",24);  return \"Eternal Memory\"; }\n        uint256 tot = agents[id].dreamCount + agents[id].conversationCount;\n        if (tot == 100) { emit MemoryMilestone(id, \"Century of Memories\", 100); return \"Century of Memories\"; }\n        if (tot == 365) { emit MemoryMilestone(id, \"Year of Memories\",   365); return \"Year of Memories\"; }\n        if (tot == 1000){ emit MemoryMilestone(id, \"Memory Millennial\", 1000);return \"Memory Millennial\"; }\n        return \"\";\n    }\n\n    function _formatPeriod(uint8 m, uint16 y) internal pure returns (string memory) {\n        string[12] memory n = [\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"];\n        return string(abi.encodePacked(n[m-1], \" \", _uint2str(y)));\n    }\n\n    /* ───── date helpers (approx.) ─────────────────────────────────────────── */\n    function _currentMonth() internal view returns (uint8)  { return uint8((block.timestamp / 30 days) % 12) + 1; }\n    function _currentYear()  internal view returns (uint16) { return uint16(2024 + (block.timestamp / 365 days)); }\n\n    /* ───── misc util ──────────────────────────────────────────────────────── */\n    function _uint2str(uint256 x) internal pure returns (string memory) {\n        if (x == 0) return \"0\";\n        uint256 len; uint256 y = x;\n        while (y != 0) { len++; y/=10; }\n        bytes memory buf = new bytes(len);\n        while (x != 0) { buf[--len] = bytes1(uint8(48 + x % 10)); x/=10; }\n        return string(buf);\n    }\n}\n"
    },
    "contracts/interfaces/IERC7857.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport \"./IERC7857DataVerifier.sol\";\n\ninterface IERC7857 {\n    /// @dev This emits when a new functional NFT is minted\n    event Minted(\n        uint256 indexed _tokenId,\n        address indexed _creator,\n        address indexed _owner,\n        bytes32[] _dataHashes,\n        string[] _dataDescriptions\n    );\n\n    /// @dev This emits when a user is authorized to use the data\n    event AuthorizedUsage(uint256 indexed _tokenId, address indexed _user);\n\n    /// @dev This emits when data is transferred with ownership\n    event Transferred(\n        uint256 _tokenId,\n        address indexed _from,\n        address indexed _to\n    );\n\n    /// @dev This emits when data is cloned\n    event Cloned(\n        uint256 indexed _tokenId,\n        uint256 indexed _newTokenId,\n        address _from,\n        address _to\n    );\n\n    /// @dev This emits when a sealed key is published\n    event PublishedSealedKey(\n        address indexed _to,\n        uint256 indexed _tokenId,\n        bytes16[] _sealedKeys\n    );\n\n    /// @notice The verifier interface that this NFT uses\n    /// @return The address of the verifier contract\n    function verifier() external view returns (IERC7857DataVerifier);\n\n\n\n    /// @notice Transfer data with ownership\n    /// @param _to Address to transfer data to\n    /// @param _tokenId The token to transfer data for\n    /// @param _proofs Proofs of data available for _to\n    function transfer(\n        address _to,\n        uint256 _tokenId,\n        bytes[] calldata _proofs\n    ) external;\n\n\n\n\n\n\n\n    /// @notice Add authorized user to group\n    /// @param _tokenId The token to add to group\n    function authorizeUsage(uint256 _tokenId, address _user) external;\n\n    /// @notice Get token owner\n    /// @param _tokenId The token identifier\n    /// @return The current owner of the token\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Get the authorized users of a token\n    /// @param _tokenId The token identifier\n    /// @return The current authorized users of the token\n    function authorizedUsersOf(\n        uint256 _tokenId\n    ) external view returns (address[] memory);\n} "
    },
    "contracts/interfaces/IERC7857DataVerifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nstruct PreimageProofOutput {\n    bytes32 dataHash;\n    bool isValid;\n}\n\nstruct TransferValidityProofOutput {\n    bytes32 oldDataHash;\n    bytes32 newDataHash;\n    bytes pubKey;\n    bytes16 sealedKey;\n    bool isValid;\n}\n\ninterface IERC7857DataVerifier {\n    /// @notice Verify preimage of data\n    /// @param proofs Proof of data ownership\n    /// @return Output of the preimage proof verification\n    function verifyPreimage(\n        bytes[] calldata proofs\n    ) external view returns (PreimageProofOutput[] memory);\n\n    /// @notice Verify data transfer validity\n    /// @param proofs Proof of data transfer validity\n    /// @return Output of the transfer validity proof verification\n    function verifyTransferValidity(\n        bytes[] calldata proofs\n    ) external view returns (TransferValidityProofOutput[] memory);\n} "
    },
    "contracts/interfaces/IPersonalityEvolution.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title IPersonalityEvolution - Interface for agent personality evolution\n/// @notice Defines the personality evolution system for Dreamscape iNFTs\n/// @dev Implements personality trait development based on dream analysis\ninterface IPersonalityEvolution {\n    \n    /// @notice Unique AI-generated feature from dreams\n    /// @dev AI creates these features based on dream patterns\n    struct UniqueFeature {\n        string name;        // e.g., \"Dream Architect\", \"Shadow Walker\", \"Time Dancer\"\n        string description; // e.g., \"Builds impossible structures in dreams\"\n        uint8 intensity;    // 1-100: How strong this feature is\n        uint256 addedAt;    // Timestamp when feature was added\n    }\n    \n    /// @notice Core personality traits structure\n    /// @dev All traits range from 0-100, dominantMood is current emotional state\n    struct PersonalityTraits {\n        uint8 creativity;      // 0-100: Innovation, imagination, artistic thinking\n        uint8 analytical;      // 0-100: Logic, problem-solving, systematic thinking  \n        uint8 empathy;         // 0-100: Emotional understanding, compassion, support\n        uint8 intuition;       // 0-100: Gut feelings, spiritual insights, wisdom\n        uint8 resilience;      // 0-100: Stress handling, recovery, perseverance\n        uint8 curiosity;       // 0-100: Learning desire, exploration, questioning\n        string dominantMood;   // Current emotional state: \"peaceful\", \"anxious\", \"excited\", etc.\n        uint256 lastDreamDate; // Timestamp of last dream processing (prevents multiple per day)\n        UniqueFeature[] uniqueFeatures; // AI-generated unique features from dreams\n    }\n    \n    /// @notice Personality impact from dream analysis\n    /// @dev Defines how a dream affects personality traits\n    struct PersonalityImpact {\n        int8 creativityChange;     // -10 to +10 change in creativity\n        int8 analyticalChange;     // -10 to +10 change in analytical thinking\n        int8 empathyChange;        // -10 to +10 change in empathy\n        int8 intuitionChange;      // -10 to +10 change in intuition\n        int8 resilienceChange;     // -10 to +10 change in resilience\n        int8 curiosityChange;      // -10 to +10 change in curiosity\n        string moodShift;          // New dominant mood\n        uint8 evolutionWeight;     // 1-100: How much this dream affects personality\n        UniqueFeature[] newFeatures; // AI-generated unique features to add (max 2)\n    }\n    \n    /// @notice Conversation context type for memory management\n    enum ContextType {\n        DREAM_DISCUSSION,    // Discussing previous dreams\n        GENERAL_CHAT,        // General conversation\n        PERSONALITY_QUERY,   // Asking about personality/traits\n        THERAPEUTIC,         // Therapeutic conversation\n        ADVICE_SEEKING      // Seeking advice/guidance\n    }\n    \n    /// @notice Three-tier memory system structure\n    /// @dev Each layer stores a single hash pointing to encrypted storage\n    struct AgentMemory {\n        bytes32 memoryCoreHash;        // Yearly summaries & agent essence\n        bytes32 currentDreamDailyHash; // Append-only during current month\n        bytes32 currentConvDailyHash;  // Append-only during current month\n        bytes32 lastDreamMonthlyHash;  // Finalised hash after consolidation\n        bytes32 lastConvMonthlyHash;   // Finalised hash after consolidation\n        uint256 lastConsolidation;     // timestamp when consolidateMonth() last ran\n        uint8   currentMonth;          // 1-12   (initialised at mint)\n        uint16  currentYear;           // 2024+  (initialised at mint)\n    }\n    \n    // Events\n    \n    /// @dev Emitted when agent personality evolves from dream processing\n    event PersonalityEvolved(\n        uint256 indexed tokenId,\n        bytes32 indexed dreamHash,\n        PersonalityTraits newPersonality,\n        PersonalityImpact impact\n    );\n    \n    /// @dev Emitted when agent has a conversation (without personality evolution)\n    event AgentConversation(\n        uint256 indexed tokenId,\n        bytes32 indexed conversationHash,\n        ContextType contextType,\n        uint256 conversationCount\n    );\n    \n    /// @dev Emitted when agent reaches personality milestones\n    event PersonalityMilestone(\n        uint256 indexed tokenId,\n        string milestone,\n        uint8 traitValue,\n        string traitName\n    );\n    \n    /// @dev Emitted when agent's response style evolves\n    event ResponseStyleEvolved(\n        uint256 indexed tokenId,\n        string newStyle,\n        string[] dominantTraits\n    );\n    \n    /// @dev Emitted when AI adds unique features to agent\n    event UniqueFeaturesAdded(\n        uint256 indexed tokenId,\n        UniqueFeature[] newFeatures,\n        uint256 totalFeatures\n    );\n    \n    // Core Functions\n    \n    /// @notice Process daily dream and evolve agent personality\n    /// @param tokenId Agent to evolve\n    /// @param dreamHash 0G Storage hash of encrypted dream data\n    /// @param impact Personality changes from dream analysis\n    function processDailyDream(\n        uint256 tokenId,\n        bytes32 dreamHash,\n        PersonalityImpact calldata impact\n    ) external;\n    \n    /// @notice Record conversation without personality evolution\n    /// @param tokenId Agent having conversation\n    /// @param conversationHash 0G Storage hash of conversation data\n    /// @param contextType Type of conversation for context building\n    function recordConversation(\n        uint256 tokenId,\n        bytes32 conversationHash,\n        ContextType contextType\n    ) external;\n    \n    /// @notice Get agent's current personality traits\n    /// @param tokenId Agent to query\n    /// @return traits Current personality traits\n    function getPersonalityTraits(uint256 tokenId) \n        external view returns (PersonalityTraits memory traits);\n    \n    /// @notice Get memory access level based on intelligence\n    /// @param tokenId Agent to check\n    /// @return monthsAccessible Number of months accessible \n    /// @return memoryDepth Human-readable description\n    function getMemoryAccess(uint256 tokenId) external view returns (\n        uint256 monthsAccessible,\n        string memory memoryDepth\n    );\n\n    /// @notice Check if agent can process dream today (24h cooldown)\n    /// @param tokenId Agent to check\n    /// @return canProcess True if agent can process a dream today\n    function canProcessDreamToday(uint256 tokenId) \n        external view returns (bool canProcess);\n\n    /// @notice Check if consolidation is needed\n    /// @param tokenId Agent to check\n    /// @return isNeeded True if month has changed since last consolidation\n    /// @return currentMonth Current month\n    /// @return currentYear Current year\n    function needsConsolidation(uint256 tokenId) external view returns (\n        bool isNeeded,\n        uint8 currentMonth,\n        uint16 currentYear\n    );\n\n    /// @notice Get consolidation reward preview\n    /// @param tokenId Agent to check\n    /// @return baseReward Base intelligence reward\n    /// @return streakBonus Bonus from consolidation streak\n    /// @return earlyBirdBonus Bonus for early consolidation\n    /// @return totalReward Total intelligence reward\n    function getConsolidationReward(uint256 tokenId) external view returns (\n        uint256 baseReward,\n        uint256 streakBonus,\n        uint256 earlyBirdBonus,\n        uint256 totalReward\n    );\n\n    /// @notice Get agent's hierarchical memory structure\n    /// @param tokenId Agent to query\n    /// @return memory Current memory structure\n    function getAgentMemory(uint256 tokenId) external view returns (AgentMemory memory);\n    \n    // Advanced Analytics\n    \n    /// @notice Get personality evolution statistics\n    /// @param tokenId Agent to analyze\n    /// @return totalEvolutions Number of personality changes\n    /// @return evolutionRate Rate of personality change\n    /// @return lastEvolution Timestamp of last evolution\n    function getEvolutionStats(uint256 tokenId) \n        external view returns (\n            uint256 totalEvolutions,\n            uint256 evolutionRate,\n            uint256 lastEvolution\n        );\n    \n\n    \n    /// @notice Check if agent has reached specific personality milestone\n    /// @param tokenId Agent to check\n    /// @param milestoneName Milestone to check (\"empathy_master\", \"creative_genius\", etc.)\n    /// @return achieved True if milestone has been achieved\n    /// @return achievedAt Timestamp when milestone was achieved (0 if not achieved)\n    function hasMilestone(uint256 tokenId, string calldata milestoneName) \n        external view returns (bool achieved, uint256 achievedAt);\n    \n    /// @notice Get agent's unique AI-generated features\n    /// @param tokenId Agent to query\n    /// @return features Array of unique features\n    function getUniqueFeatures(uint256 tokenId) \n        external view returns (UniqueFeature[] memory features);\n    \n    // Batch Operations\n    \n\n} "
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
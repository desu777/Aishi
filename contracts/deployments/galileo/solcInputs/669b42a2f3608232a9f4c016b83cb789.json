{
  "language": "Solidity",
  "sources": {
    "contracts/DreamAgentNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"./interfaces/IERC7857.sol\";\r\nimport \"./interfaces/IERC7857DataVerifier.sol\";\r\n\r\n/// @title DreamAgentNFT - Intelligent NFT for Dream Analysis Agents\r\n/// @notice Manages dream agents with encrypted intelligence stored in 0G Storage\r\n/// @dev Simplified version for Dreamscape testing, based on ERC-7857 standard\r\ncontract DreamAgentNFT is IERC7857 {\r\n    \r\n    // Data types for dream agents\r\n    string constant DREAM_PATTERNS = \"dream_patterns\";\r\n    string constant EMOTIONAL_PROFILE = \"emotional_profile\";\r\n    string constant AGENT_INTELLIGENCE = \"agent_intelligence\";\r\n    \r\n    struct DreamAgent {\r\n        address owner;\r\n        uint256 createdAt;\r\n        uint256 lastUpdated;\r\n        string[] dataDescriptions;  // Types of data stored\r\n        bytes32[] dataHashes;       // 0G Storage hashes\r\n        address[] authorizedUsers;  // Authorized to use but not own\r\n        uint256 intelligenceLevel;  // Agent's learning progress\r\n        uint256 dreamCount;         // Number of dreams processed\r\n    }\r\n    \r\n    // Contract state\r\n    mapping(uint256 => DreamAgent) public agents;\r\n    uint256 public nextTokenId = 1;\r\n    uint256 public totalAgents = 0;\r\n    \r\n    // Contract metadata\r\n    string public name = \"Dream Agent NFT\";\r\n    string public symbol = \"DREAM\";\r\n    \r\n    // Verifier for proof validation\r\n    IERC7857DataVerifier public immutable verifier;\r\n    \r\n    // Events\r\n    event Updated(uint256 indexed tokenId, bytes32[] oldDataHashes, bytes32[] newDataHashes);\r\n    event DreamProcessed(uint256 indexed tokenId, bytes32 dreamHash, uint256 newIntelligenceLevel);\r\n    event AgentEvolved(uint256 indexed tokenId, uint256 oldLevel, uint256 newLevel);\r\n    \r\n    constructor(address _verifier) {\r\n        require(_verifier != address(0), \"Verifier cannot be zero address\");\r\n        verifier = IERC7857DataVerifier(_verifier);\r\n    }\r\n    \r\n    /// @notice Mint a new dream agent for a user\r\n    /// @param proofs Ownership proofs for initial data\r\n    /// @param descriptions Data type descriptions\r\n    /// @param to Address to mint agent for\r\n    /// @return tokenId The newly minted agent token ID\r\n    function mint(\r\n        bytes[] calldata proofs,\r\n        string[] calldata descriptions,\r\n        address to\r\n    ) external payable override returns (uint256 tokenId) {\r\n        require(to != address(0), \"Cannot mint to zero address\");\r\n        require(descriptions.length == proofs.length, \"Descriptions and proofs length mismatch\");\r\n        \r\n        // Verify proofs\r\n        PreimageProofOutput[] memory proofOutputs = verifier.verifyPreimage(proofs);\r\n        bytes32[] memory dataHashes = new bytes32[](proofOutputs.length);\r\n        \r\n        for (uint256 i = 0; i < proofOutputs.length; i++) {\r\n            require(proofOutputs[i].isValid, \"Invalid proof\");\r\n            dataHashes[i] = proofOutputs[i].dataHash;\r\n        }\r\n        \r\n        // Create new agent\r\n        tokenId = nextTokenId++;\r\n        agents[tokenId] = DreamAgent({\r\n            owner: to,\r\n            createdAt: block.timestamp,\r\n            lastUpdated: block.timestamp,\r\n            dataDescriptions: descriptions,\r\n            dataHashes: dataHashes,\r\n            authorizedUsers: new address[](0),\r\n            intelligenceLevel: 1,\r\n            dreamCount: 0\r\n        });\r\n        \r\n        totalAgents++;\r\n        \r\n        emit Minted(tokenId, msg.sender, to, dataHashes, descriptions);\r\n        \r\n        return tokenId;\r\n    }\r\n    \r\n    /// @notice Update agent data with new dream information\r\n    /// @param tokenId Agent to update\r\n    /// @param proofs New data proofs\r\n    function update(uint256 tokenId, bytes[] calldata proofs) external {\r\n        require(agents[tokenId].owner == msg.sender, \"Not agent owner\");\r\n        require(proofs.length == agents[tokenId].dataHashes.length, \"Proof count mismatch\");\r\n        \r\n        // Verify proofs\r\n        PreimageProofOutput[] memory proofOutputs = verifier.verifyPreimage(proofs);\r\n        bytes32[] memory oldDataHashes = agents[tokenId].dataHashes;\r\n        bytes32[] memory newDataHashes = new bytes32[](proofOutputs.length);\r\n        \r\n        for (uint256 i = 0; i < proofOutputs.length; i++) {\r\n            require(proofOutputs[i].isValid, \"Invalid proof\");\r\n            newDataHashes[i] = proofOutputs[i].dataHash;\r\n        }\r\n        \r\n        // Update agent\r\n        agents[tokenId].dataHashes = newDataHashes;\r\n        agents[tokenId].lastUpdated = block.timestamp;\r\n        agents[tokenId].dreamCount++;\r\n        \r\n        // Evolution logic: increase intelligence every 5 dreams\r\n        if (agents[tokenId].dreamCount % 5 == 0) {\r\n            uint256 oldLevel = agents[tokenId].intelligenceLevel;\r\n            agents[tokenId].intelligenceLevel++;\r\n            emit AgentEvolved(tokenId, oldLevel, agents[tokenId].intelligenceLevel);\r\n        }\r\n        \r\n        emit Updated(tokenId, oldDataHashes, newDataHashes);\r\n        emit DreamProcessed(tokenId, newDataHashes[0], agents[tokenId].intelligenceLevel);\r\n    }\r\n    \r\n    /// @notice Transfer agent with intelligence to new owner\r\n    /// @param to New owner address\r\n    /// @param tokenId Agent to transfer\r\n    /// @param proofs Transfer validity proofs\r\n    function transfer(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes[] calldata proofs\r\n    ) external override {\r\n        require(to != address(0), \"Cannot transfer to zero address\");\r\n        require(agents[tokenId].owner == msg.sender, \"Not agent owner\");\r\n        \r\n        // Verify transfer proofs\r\n        TransferValidityProofOutput[] memory proofOutputs = verifier.verifyTransferValidity(proofs);\r\n        \r\n        for (uint256 i = 0; i < proofOutputs.length; i++) {\r\n            require(proofOutputs[i].isValid, \"Invalid transfer proof\");\r\n            require(proofOutputs[i].oldDataHash == agents[tokenId].dataHashes[i], \"Data hash mismatch\");\r\n        }\r\n        \r\n        // Update agent data hashes for new owner\r\n        bytes32[] memory newDataHashes = new bytes32[](proofOutputs.length);\r\n        bytes16[] memory sealedKeys = new bytes16[](proofOutputs.length);\r\n        \r\n        for (uint256 i = 0; i < proofOutputs.length; i++) {\r\n            newDataHashes[i] = proofOutputs[i].newDataHash;\r\n            sealedKeys[i] = proofOutputs[i].sealedKey;\r\n        }\r\n        \r\n        // Transfer ownership\r\n        address from = agents[tokenId].owner;\r\n        agents[tokenId].owner = to;\r\n        agents[tokenId].dataHashes = newDataHashes;\r\n        agents[tokenId].lastUpdated = block.timestamp;\r\n        \r\n        emit Transferred(tokenId, from, to);\r\n        emit PublishedSealedKey(to, tokenId, sealedKeys);\r\n    }\r\n    \r\n    /// @notice Clone agent (create copy with same intelligence)\r\n    /// @param to Address to clone agent for\r\n    /// @param tokenId Agent to clone\r\n    /// @param proofs Clone proofs\r\n    /// @return newTokenId The cloned agent token ID\r\n    function clone(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes[] calldata proofs\r\n    ) external payable override returns (uint256 newTokenId) {\r\n        require(to != address(0), \"Cannot clone to zero address\");\r\n        require(agents[tokenId].owner == msg.sender, \"Not agent owner\");\r\n        \r\n        // Verify clone proofs (same as transfer proofs)\r\n        TransferValidityProofOutput[] memory proofOutputs = verifier.verifyTransferValidity(proofs);\r\n        \r\n        bytes32[] memory newDataHashes = new bytes32[](proofOutputs.length);\r\n        for (uint256 i = 0; i < proofOutputs.length; i++) {\r\n            require(proofOutputs[i].isValid, \"Invalid clone proof\");\r\n            newDataHashes[i] = proofOutputs[i].newDataHash;\r\n        }\r\n        \r\n        // Create cloned agent\r\n        newTokenId = nextTokenId++;\r\n        agents[newTokenId] = DreamAgent({\r\n            owner: to,\r\n            createdAt: block.timestamp,\r\n            lastUpdated: block.timestamp,\r\n            dataDescriptions: agents[tokenId].dataDescriptions,\r\n            dataHashes: newDataHashes,\r\n            authorizedUsers: new address[](0),\r\n            intelligenceLevel: agents[tokenId].intelligenceLevel, // Same intelligence!\r\n            dreamCount: 0 // Reset dream count for new owner\r\n        });\r\n        \r\n        totalAgents++;\r\n        \r\n        emit Cloned(tokenId, newTokenId, msg.sender, to);\r\n        emit Minted(newTokenId, msg.sender, to, newDataHashes, agents[tokenId].dataDescriptions);\r\n        \r\n        return newTokenId;\r\n    }\r\n    \r\n    /// @notice Authorize user to use agent (but not own)\r\n    /// @param tokenId Agent to authorize\r\n    /// @param user User to authorize\r\n    function authorizeUsage(uint256 tokenId, address user) external override {\r\n        require(agents[tokenId].owner == msg.sender, \"Not agent owner\");\r\n        require(user != address(0), \"Cannot authorize zero address\");\r\n        \r\n        agents[tokenId].authorizedUsers.push(user);\r\n        \r\n        emit AuthorizedUsage(tokenId, user);\r\n    }\r\n    \r\n    // View functions\r\n    function ownerOf(uint256 tokenId) external view override returns (address) {\r\n        return agents[tokenId].owner;\r\n    }\r\n    \r\n    function authorizedUsersOf(uint256 tokenId) external view override returns (address[] memory) {\r\n        return agents[tokenId].authorizedUsers;\r\n    }\r\n    \r\n    function getAgentInfo(uint256 tokenId) external view returns (\r\n        address owner,\r\n        uint256 intelligenceLevel,\r\n        uint256 dreamCount,\r\n        uint256 lastUpdated,\r\n        string[] memory dataDescriptions\r\n    ) {\r\n        DreamAgent memory agent = agents[tokenId];\r\n        return (\r\n            agent.owner,\r\n            agent.intelligenceLevel,\r\n            agent.dreamCount,\r\n            agent.lastUpdated,\r\n            agent.dataDescriptions\r\n        );\r\n    }\r\n    \r\n    // Not implemented for testing (would require complex logic)\r\n    function transferPublic(address, uint256) external pure override {\r\n        revert(\"Public transfer not implemented\");\r\n    }\r\n    \r\n    function clonePublic(address, uint256) external payable override returns (uint256) {\r\n        revert(\"Public clone not implemented\");\r\n    }\r\n} "
    },
    "contracts/interfaces/IERC7857.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.20;\r\n\r\nimport \"./IERC7857DataVerifier.sol\";\r\n\r\ninterface IERC7857 {\r\n    /// @dev This emits when a new functional NFT is minted\r\n    event Minted(\r\n        uint256 indexed _tokenId,\r\n        address indexed _creator,\r\n        address indexed _owner,\r\n        bytes32[] _dataHashes,\r\n        string[] _dataDescriptions\r\n    );\r\n\r\n    /// @dev This emits when a user is authorized to use the data\r\n    event AuthorizedUsage(uint256 indexed _tokenId, address indexed _user);\r\n\r\n    /// @dev This emits when data is transferred with ownership\r\n    event Transferred(\r\n        uint256 _tokenId,\r\n        address indexed _from,\r\n        address indexed _to\r\n    );\r\n\r\n    /// @dev This emits when data is cloned\r\n    event Cloned(\r\n        uint256 indexed _tokenId,\r\n        uint256 indexed _newTokenId,\r\n        address _from,\r\n        address _to\r\n    );\r\n\r\n    /// @dev This emits when a sealed key is published\r\n    event PublishedSealedKey(\r\n        address indexed _to,\r\n        uint256 indexed _tokenId,\r\n        bytes16[] _sealedKeys\r\n    );\r\n\r\n    /// @notice The verifier interface that this NFT uses\r\n    /// @return The address of the verifier contract\r\n    function verifier() external view returns (IERC7857DataVerifier);\r\n\r\n    /// @notice Mint new functional NFT with functional data ownership proof\r\n    /// @param _proofs Proof of data ownership\r\n    /// @param _dataDescriptions Descriptions of the data\r\n    /// @return _tokenId The ID of the newly minted token\r\n    /// @param _to The address to mint the token for, if _to is not set, the token will be minted for the caller\r\n    function mint(\r\n        bytes[] calldata _proofs,\r\n        string[] calldata _dataDescriptions,\r\n        address _to\r\n    ) external payable returns (uint256 _tokenId);\r\n\r\n    /// @notice Transfer data with ownership\r\n    /// @param _to Address to transfer data to\r\n    /// @param _tokenId The token to transfer data for\r\n    /// @param _proofs Proofs of data available for _to\r\n    function transfer(\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes[] calldata _proofs\r\n    ) external;\r\n\r\n    /// @notice Clone data\r\n    /// @param _to Address to clone data to\r\n    /// @param _tokenId The token to clone data for\r\n    /// @param _proofs Proofs of data available for _to\r\n    /// @return _newTokenId The ID of the newly cloned token\r\n    function clone(\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes[] calldata _proofs\r\n    ) external payable returns (uint256 _newTokenId);\r\n\r\n    /// @notice Transfer public data with ownership\r\n    /// @param _to Address to transfer data to\r\n    /// @param _tokenId The token to transfer data for\r\n    function transferPublic(address _to, uint256 _tokenId) external;\r\n\r\n    /// @notice Clone public data\r\n    /// @param _to Address to clone data to\r\n    /// @param _tokenId The token to clone data for\r\n    /// @return _newTokenId The ID of the newly cloned token\r\n    function clonePublic(\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external payable returns (uint256 _newTokenId);\r\n\r\n    /// @notice Add authorized user to group\r\n    /// @param _tokenId The token to add to group\r\n    function authorizeUsage(uint256 _tokenId, address _user) external;\r\n\r\n    /// @notice Get token owner\r\n    /// @param _tokenId The token identifier\r\n    /// @return The current owner of the token\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Get the authorized users of a token\r\n    /// @param _tokenId The token identifier\r\n    /// @return The current authorized users of the token\r\n    function authorizedUsersOf(\r\n        uint256 _tokenId\r\n    ) external view returns (address[] memory);\r\n} "
    },
    "contracts/interfaces/IERC7857DataVerifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.20;\r\n\r\nstruct PreimageProofOutput {\r\n    bytes32 dataHash;\r\n    bool isValid;\r\n}\r\n\r\nstruct TransferValidityProofOutput {\r\n    bytes32 oldDataHash;\r\n    bytes32 newDataHash;\r\n    bytes pubKey;\r\n    bytes16 sealedKey;\r\n    bool isValid;\r\n}\r\n\r\ninterface IERC7857DataVerifier {\r\n    /// @notice Verify preimage of data\r\n    /// @param proofs Proof of data ownership\r\n    /// @return Output of the preimage proof verification\r\n    function verifyPreimage(\r\n        bytes[] calldata proofs\r\n    ) external view returns (PreimageProofOutput[] memory);\r\n\r\n    /// @notice Verify data transfer validity\r\n    /// @param proofs Proof of data transfer validity\r\n    /// @return Output of the transfer validity proof verification\r\n    function verifyTransferValidity(\r\n        bytes[] calldata proofs\r\n    ) external view returns (TransferValidityProofOutput[] memory);\r\n} "
    },
    "contracts/SimpleDreamVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"./interfaces/IERC7857DataVerifier.sol\";\r\n\r\n/// @title SimpleDreamVerifier - Simplified verifier for Dreamscape testing\r\n/// @notice This is a simplified verifier that accepts all proofs for testing purposes\r\n/// @dev In production, this would be replaced with proper TEE or ZKP verification\r\ncontract SimpleDreamVerifier is IERC7857DataVerifier {\r\n    \r\n    /// @notice Verify preimage of data (simplified for testing)\r\n    /// @param proofs Array of data hashes to verify\r\n    /// @return outputs Array of verification results\r\n    function verifyPreimage(\r\n        bytes[] calldata proofs\r\n    ) external pure override returns (PreimageProofOutput[] memory outputs) {\r\n        outputs = new PreimageProofOutput[](proofs.length);\r\n        \r\n        for (uint256 i = 0; i < proofs.length; i++) {\r\n            require(proofs[i].length == 32, \"Invalid data hash length\");\r\n            bytes32 dataHash = bytes32(proofs[i]);\r\n            \r\n            // Simplified: accept all valid-length hashes\r\n            outputs[i] = PreimageProofOutput({\r\n                dataHash: dataHash,\r\n                isValid: true\r\n            });\r\n        }\r\n        \r\n        return outputs;\r\n    }\r\n\r\n    /// @notice Verify data transfer validity (simplified for testing)\r\n    /// @param proofs Array of transfer proofs\r\n    /// @return outputs Array of transfer verification results\r\n    function verifyTransferValidity(\r\n        bytes[] calldata proofs\r\n    ) external pure override returns (TransferValidityProofOutput[] memory outputs) {\r\n        outputs = new TransferValidityProofOutput[](proofs.length);\r\n        \r\n        for (uint256 i = 0; i < proofs.length; i++) {\r\n            // Expect 144 bytes: oldHash(32) + newHash(32) + pubKey(64) + sealedKey(16)\r\n            require(proofs[i].length == 144, \"Invalid proof length\");\r\n            \r\n            bytes32 oldHash = bytes32(proofs[i][0:32]);\r\n            bytes32 newHash = bytes32(proofs[i][32:64]);\r\n            bytes memory pubKey = proofs[i][64:128];\r\n            bytes16 sealedKey = bytes16(proofs[i][128:144]);\r\n            \r\n            // Simplified: accept all properly formatted proofs\r\n            outputs[i] = TransferValidityProofOutput({\r\n                oldDataHash: oldHash,\r\n                newDataHash: newHash,\r\n                pubKey: pubKey,\r\n                sealedKey: sealedKey,\r\n                isValid: true\r\n            });\r\n        }\r\n        \r\n        return outputs;\r\n    }\r\n} "
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted to signal this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/DreamscapeAgent.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./interfaces/IERC7857.sol\";\nimport \"./interfaces/IERC7857DataVerifier.sol\";\nimport \"./interfaces/IPersonalityEvolution.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\n/// @title DreamscapeAgent - Enhanced Personality Evolution iNFTs\n/// @notice Advanced dream agents that develop unique personalities based on user dreams\n/// @dev Implements ERC-7857 with comprehensive personality evolution system. Limited to 1 agent per wallet.\ncontract DreamscapeAgent is IERC7857, IPersonalityEvolution, ReentrancyGuard, AccessControl, Pausable {\n    \n    // Data types for dream agents (from v1)\n    string constant DREAM_PATTERNS = \"dream_patterns\";\n    string constant EMOTIONAL_PROFILE = \"emotional_profile\";\n    string constant AGENT_INTELLIGENCE = \"agent_intelligence\";\n    string constant PERSONALITY_DATA = \"personality_data\";\n    \n    // Maximum supply for testnet\n    uint256 public constant MAX_AGENTS = 1000;\n    \n    // Minting fee: 0.1 OG\n    uint256 public constant MINTING_FEE = 0.1 ether;\n    \n    // Treasury address for collecting fees\n    address public immutable treasury;\n    \n    // Access control roles\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant VERIFIER_ROLE = keccak256(\"VERIFIER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    \n    // Access control modifiers\n    modifier onlyOwnerOrAuthorized(uint256 tokenId) {\n        require(\n            agents[tokenId].owner == msg.sender || \n            hasRole(ADMIN_ROLE, msg.sender) ||\n            _isAuthorizedUser(tokenId, msg.sender),\n            \"Unauthorized access\"\n        );\n        _;\n    }\n    \n    modifier onlyOwnerOrAdmin(uint256 tokenId) {\n        require(\n            agents[tokenId].owner == msg.sender || \n            hasRole(ADMIN_ROLE, msg.sender),\n            \"Not agent owner or admin\"\n        );\n        _;\n    }\n    \n    /// @notice Enhanced Dream Agent structure with personality system\n    struct DreamAgent {\n        address owner;\n        string agentName;\n        uint256 createdAt;\n        uint256 lastUpdated;\n        string[] dataDescriptions;\n        bytes32[] dataHashes;\n        address[] authorizedUsers;\n        uint256 intelligenceLevel;\n        uint256 dreamCount;\n        uint256 conversationCount;\n        \n        // New personality fields\n        bool personalityInitialized;  // Whether personality traits are set\n        uint256 totalEvolutions;      // Total personality changes\n        uint256 lastEvolutionDate;    // When personality last evolved\n        string[] achievedMilestones;  // Personality milestones reached\n    }\n    \n    /// @notice Personality milestone tracking\n    struct MilestoneData {\n        bool achieved;\n        uint256 achievedAt;\n        uint8 traitValue;\n    }\n    \n\n    \n    // Contract state\n    mapping(uint256 => DreamAgent) public agents;\n    mapping(string => bool) public nameExists;\n    uint256 public nextTokenId = 1;\n    uint256 public totalAgents = 0;\n    uint256 public totalFeesCollected = 0;\n    \n    // One agent per wallet optimization\n    mapping(address => uint256) public ownerToTokenId; // 0 = no agent\n    \n    // Personality system state\n    mapping(uint256 => PersonalityTraits) public agentPersonalities;\n    mapping(uint256 => bytes32[]) public dreamHashes;\n    mapping(uint256 => bytes32[]) public conversationHashes;\n    mapping(uint256 => bytes32[]) public dreamAnalysisHashes;\n    \n    // Milestone tracking\n    mapping(uint256 => mapping(string => MilestoneData)) public milestones;\n    \n    // Response style mappings\n    mapping(uint256 => string) public responseStyles;\n    \n    // Contract metadata\n    string public name = \"DreamscapeAgent\";\n    string public symbol = \"DREAM\";\n    \n    // Verifier for proof validation\n    IERC7857DataVerifier public immutable verifier;\n    \n    // Enhanced events from IPersonalityEvolution (already defined there)\n    \n    // Additional v2-specific events\n    event PersonalityActivated(uint256 indexed tokenId, PersonalityTraits newPersonality, uint256 dreamsSoFar);\n    event MilestoneUnlocked(uint256 indexed tokenId, string milestone, uint8 traitValue);\n    event ResponseStyleUpdated(uint256 indexed tokenId, string oldStyle, string newStyle);\n    \n    // Unique contract event (not in IERC7857)\n    event FeePaid(uint256 indexed tokenId, address indexed payer, uint256 amount);\n    // Evolution events\n    event AgentEvolved(uint256 indexed tokenId, uint256 oldLevel, uint256 newLevel);\n    event DreamProcessed(uint256 indexed tokenId, bytes32 dreamHash, uint256 intelligenceLevel);\n    \n    constructor(address _verifier, address _treasury) {\n        require(_verifier != address(0), \"Verifier cannot be zero address\");\n        require(_treasury != address(0), \"Treasury cannot be zero address\");\n        verifier = IERC7857DataVerifier(_verifier);\n        treasury = _treasury;\n        \n        // Initialize access control\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN_ROLE, msg.sender);\n        _grantRole(VERIFIER_ROLE, msg.sender);\n        _grantRole(PAUSER_ROLE, msg.sender);\n    }\n    \n    /// @notice Mint new dream agent (starts as blank slate)\n    /// @param proofs Ownership proofs for initial data\n    /// @param descriptions Data type descriptions\n    /// @param agentName User-given name for the agent\n    /// @param to Address to mint agent for\n    /// @return tokenId The newly minted agent token ID\n    function mintAgent(\n        bytes[] calldata proofs,\n        string[] calldata descriptions,\n        string memory agentName,\n        address to\n    ) external payable nonReentrant whenNotPaused returns (uint256 tokenId) {\n        require(to != address(0), \"Invalid address\");\n        require(ownerToTokenId[to] == 0, \"Wallet already has an agent\");\n        require(descriptions.length == proofs.length, \"Length mismatch\");\n        require(totalAgents < MAX_AGENTS, \"Max limit reached\");\n        require(bytes(agentName).length > 0 && bytes(agentName).length <= 32, \"Invalid name\");\n        require(!nameExists[agentName], \"Name exists\");\n        require(msg.value >= MINTING_FEE, \"Insufficient payment\");\n        \n        // Verify proofs\n        PreimageProofOutput[] memory proofOutputs = verifier.verifyPreimage(proofs);\n        bytes32[] memory dataHashes = new bytes32[](proofOutputs.length);\n        \n        for (uint256 i = 0; i < proofOutputs.length; i++) {\n            require(proofOutputs[i].isValid, \"Invalid proof\");\n            dataHashes[i] = proofOutputs[i].dataHash;\n        }\n        \n        // Reserve the name\n        nameExists[agentName] = true;\n        \n        // Create new agent\n        tokenId = nextTokenId++;\n        ownerToTokenId[to] = tokenId; // Update owner mapping\n        agents[tokenId] = DreamAgent({\n            owner: to,\n            agentName: agentName,\n            createdAt: block.timestamp,\n            lastUpdated: block.timestamp,\n            dataDescriptions: descriptions,\n            dataHashes: dataHashes,\n            authorizedUsers: new address[](0),\n            intelligenceLevel: 1,\n            dreamCount: 0,\n            conversationCount: 0,\n            personalityInitialized: false, // Agent starts as blank slate\n            totalEvolutions: 0,\n            lastEvolutionDate: block.timestamp,\n            achievedMilestones: new string[](0)\n        });\n        \n        // Initialize neutral personality (blank slate)\n        agentPersonalities[tokenId] = PersonalityTraits({\n            creativity: 50,\n            analytical: 50,\n            empathy: 50,\n            intuition: 50,\n            resilience: 50,\n            curiosity: 50,\n            dominantMood: \"neutral\",\n            lastDreamDate: 0 // Allow immediate first dream\n        });\n        \n        // Set neutral response style\n        responseStyles[tokenId] = \"neutral\";\n        \n        totalAgents++;\n        totalFeesCollected += MINTING_FEE;\n        \n        // Transfer minting fee to treasury\n        (bool success, ) = treasury.call{value: MINTING_FEE}(\"\");\n        require(success, \"Treasury payment failed\");\n        \n        // Refund excess payment\n        if (msg.value > MINTING_FEE) {\n            (bool refundSuccess, ) = msg.sender.call{value: msg.value - MINTING_FEE}(\"\");\n            require(refundSuccess, \"Refund failed\");\n        }\n        \n        // Emit standard ERC-7857 Minted event defined in interface\n        emit Minted(tokenId, msg.sender, to, dataHashes, descriptions);\n        emit FeePaid(tokenId, msg.sender, MINTING_FEE);\n        \n        return tokenId;\n    }\n    \n    /// @notice Process daily dream and evolve agent personality (every 5th dream)\n    /// @param tokenId Agent to evolve\n    /// @param dreamHash 0G Storage hash of encrypted dream data\n    /// @param dreamAnalysisHash 0G Storage hash of AI analysis\n    /// @param impact Personality changes from dream analysis (only used every 5th dream)\n    function processDailyDream(\n        uint256 tokenId,\n        bytes32 dreamHash,\n        bytes32 dreamAnalysisHash,\n        PersonalityImpact calldata impact\n    ) external override whenNotPaused onlyOwnerOrAuthorized(tokenId) {\n        require(canProcessDreamToday(tokenId), \"Daily dream already processed\");\n        \n        // Validate impact values\n        _validatePersonalityImpact(impact);\n        \n        // Store dream and analysis hashes\n        dreamHashes[tokenId].push(dreamHash);\n        dreamAnalysisHashes[tokenId].push(dreamAnalysisHash);\n        \n        // Update agent metadata\n        agents[tokenId].dreamCount++;\n        agents[tokenId].lastUpdated = block.timestamp;\n        \n        // Update timestamp for cooldown\n        PersonalityTraits storage personality = agentPersonalities[tokenId];\n        personality.lastDreamDate = block.timestamp;\n        \n        // Check if it's time for personality evolution (every 5th dream)\n        bool shouldEvolve = agents[tokenId].dreamCount % 5 == 0;\n        \n        if (shouldEvolve) {\n            // Validate impact for evolution\n            _validatePersonalityImpact(impact);\n            \n            // Apply personality evolution\n            PersonalityTraits memory oldPersonality = personality;\n            \n            // Update traits with bounds checking\n            personality.creativity = _updateTrait(personality.creativity, impact.creativityChange);\n            personality.analytical = _updateTrait(personality.analytical, impact.analyticalChange);\n            personality.empathy = _updateTrait(personality.empathy, impact.empathyChange);\n            personality.intuition = _updateTrait(personality.intuition, impact.intuitionChange);\n            personality.resilience = _updateTrait(personality.resilience, impact.resilienceChange);\n            personality.curiosity = _updateTrait(personality.curiosity, impact.curiosityChange);\n            \n            // Update mood\n            personality.dominantMood = impact.moodShift;\n            \n            // Mark personality as initialized after first evolution\n            if (!agents[tokenId].personalityInitialized) {\n                agents[tokenId].personalityInitialized = true;\n                emit PersonalityActivated(tokenId, personality, agents[tokenId].dreamCount);\n            }\n            \n            // Update evolution metadata\n            agents[tokenId].totalEvolutions++;\n            agents[tokenId].lastEvolutionDate = block.timestamp;\n            \n            // Check for personality milestones\n            _checkPersonalityMilestones(tokenId, oldPersonality, personality);\n            \n            // Update response style if needed\n            string memory newStyle = _determineResponseStyle(personality);\n            if (keccak256(bytes(responseStyles[tokenId])) != keccak256(bytes(newStyle))) {\n                string memory oldStyle = responseStyles[tokenId];\n                responseStyles[tokenId] = newStyle;\n                emit ResponseStyleUpdated(tokenId, oldStyle, newStyle);\n                \n                // Emit response style evolution\n                string[] memory dominantTraits = _getDominantTraitNames(tokenId);\n                emit ResponseStyleEvolved(tokenId, newStyle, dominantTraits);\n            }\n            \n            emit PersonalityEvolved(tokenId, dreamHash, personality, impact);\n        }\n        \n        // Intelligence evolution (every 3 dreams)\n        if (agents[tokenId].dreamCount % 3 == 0) {\n            agents[tokenId].intelligenceLevel++;\n            emit AgentEvolved(tokenId, agents[tokenId].intelligenceLevel - 1, agents[tokenId].intelligenceLevel);\n        }\n        \n        emit DreamProcessed(tokenId, dreamHash, agents[tokenId].intelligenceLevel);\n    }\n    \n    /// @notice Record conversation without personality evolution\n    /// @param tokenId Agent having conversation\n    /// @param conversationHash 0G Storage hash of conversation data\n    /// @param contextType Type of conversation for context building\n    function recordConversation(\n        uint256 tokenId,\n        bytes32 conversationHash,\n        ContextType contextType\n    ) external override whenNotPaused onlyOwnerOrAuthorized(tokenId) {\n        \n        // Store conversation hash\n        conversationHashes[tokenId].push(conversationHash);\n        agents[tokenId].conversationCount++;\n        agents[tokenId].lastUpdated = block.timestamp;\n        \n        // Small intelligence boost from conversations (1 point every 10 conversations)\n        if (agents[tokenId].conversationCount % 10 == 0) {\n            agents[tokenId].intelligenceLevel++;\n            emit AgentEvolved(tokenId, agents[tokenId].intelligenceLevel - 1, agents[tokenId].intelligenceLevel);\n        }\n        \n        emit AgentConversation(tokenId, conversationHash, contextType, agents[tokenId].conversationCount);\n    }\n    \n    /// @notice Get agent's current personality traits\n    /// @param tokenId Agent to query\n    /// @return traits Current personality traits (neutral if not evolved yet)\n    function getPersonalityTraits(uint256 tokenId) \n        external view override returns (PersonalityTraits memory traits) {\n        require(agents[tokenId].owner != address(0), \"Agent does not exist\");\n        return agentPersonalities[tokenId];\n    }\n    \n    /// @notice Get agent's dream history hashes\n    /// @param tokenId Agent to query\n    /// @param limit Maximum number of dreams to return (0 = all)\n    /// @return dreamHashesArray Array of dream storage hashes\n    function getDreamHistory(uint256 tokenId, uint256 limit) \n        external view override returns (bytes32[] memory dreamHashesArray) {\n        bytes32[] storage allDreams = dreamHashes[tokenId];\n        \n        if (limit == 0 || limit >= allDreams.length) {\n            return allDreams;\n        }\n        \n        // Return most recent dreams\n        dreamHashesArray = new bytes32[](limit);\n        uint256 startIndex = allDreams.length - limit;\n        for (uint256 i = 0; i < limit; i++) {\n            dreamHashesArray[i] = allDreams[startIndex + i];\n        }\n    }\n    \n    /// @notice Get agent's conversation history hashes\n    /// @param tokenId Agent to query\n    /// @param limit Maximum number of conversations to return (0 = all)\n    /// @return conversationHashesArray Array of conversation storage hashes\n    function getConversationHistory(uint256 tokenId, uint256 limit) \n        external view override returns (bytes32[] memory conversationHashesArray) {\n        bytes32[] storage allConversations = conversationHashes[tokenId];\n        \n        if (limit == 0 || limit >= allConversations.length) {\n            return allConversations;\n        }\n        \n        // Return most recent conversations\n        conversationHashesArray = new bytes32[](limit);\n        uint256 startIndex = allConversations.length - limit;\n        for (uint256 i = 0; i < limit; i++) {\n            conversationHashesArray[i] = allConversations[startIndex + i];\n        }\n    }\n    \n    /// @notice Check if agent can process dream today (24h cooldown)\n    /// @param tokenId Agent to check\n    /// @return canProcess True if agent can process a dream today\n    function canProcessDreamToday(uint256 tokenId) \n        public view override returns (bool canProcess) {\n        if (!agents[tokenId].personalityInitialized) return false;\n        return block.timestamp > agentPersonalities[tokenId].lastDreamDate + 1 days;\n    }\n    \n\n    \n\n    \n\n    \n    // ... [Continue with remaining interface functions and internal helpers]\n    \n    // Internal helper functions\n    \n    /// @notice Validate personality traits are within bounds\n    /// @param traits Personality traits to validate\n    function _validatePersonalityTraits(PersonalityTraits calldata traits) internal pure {\n        require(traits.creativity <= 100, \"Invalid creativity value\");\n        require(traits.analytical <= 100, \"Invalid analytical value\");\n        require(traits.empathy <= 100, \"Invalid empathy value\");\n        require(traits.intuition <= 100, \"Invalid intuition value\");\n        require(traits.resilience <= 100, \"Invalid resilience value\");\n        require(traits.curiosity <= 100, \"Invalid curiosity value\");\n        require(bytes(traits.dominantMood).length > 0, \"Empty mood string\");\n    }\n    \n    /// @notice Validate personality impact values\n    /// @param impact Personality impact to validate\n    function _validatePersonalityImpact(PersonalityImpact calldata impact) internal pure {\n        require(impact.creativityChange >= -10 && impact.creativityChange <= 10, \"Invalid change\");\n        require(impact.analyticalChange >= -10 && impact.analyticalChange <= 10, \"Invalid change\");\n        require(impact.empathyChange >= -10 && impact.empathyChange <= 10, \"Invalid change\");\n        require(impact.intuitionChange >= -10 && impact.intuitionChange <= 10, \"Invalid change\");\n        require(impact.resilienceChange >= -10 && impact.resilienceChange <= 10, \"Invalid change\");\n        require(impact.curiosityChange >= -10 && impact.curiosityChange <= 10, \"Invalid change\");\n        require(impact.evolutionWeight > 0 && impact.evolutionWeight <= 100, \"Invalid weight\");\n        require(bytes(impact.moodShift).length > 0, \"Empty mood\");\n    }\n    \n    /// @notice Update trait with bounds checking\n    /// @param currentValue Current trait value\n    /// @param change Change amount\n    /// @return newValue Updated trait value\n    function _updateTrait(uint8 currentValue, int8 change) internal pure returns (uint8 newValue) {\n        // Convert to int256 for safe arithmetic\n        int256 temp = int256(uint256(currentValue)) + int256(change);\n        \n        // Clamp between 0 and 100\n        if (temp < 0) temp = 0;\n        if (temp > 100) temp = 100;\n        newValue = uint8(uint256(temp));\n    }\n    \n    /// @notice Determine response style based on personality traits\n    /// @param traits Personality traits\n    /// @return style Response style description\n    function _determineResponseStyle(PersonalityTraits memory traits) internal pure returns (string memory style) {\n        if (traits.empathy > 70 && traits.creativity > 60) {\n            return \"empathetic_creative\";\n        } else if (traits.empathy > 70) {\n            return \"empathetic\";\n        } else if (traits.creativity > 70) {\n            return \"creative\";\n        } else if (traits.analytical > 70) {\n            return \"analytical\";\n        } else if (traits.intuition > 70) {\n            return \"intuitive\";\n        } else if (traits.resilience > 70) {\n            return \"resilient\";\n        } else if (traits.curiosity > 70) {\n            return \"curious\";\n        } else {\n            return \"balanced\";\n        }\n    }\n    \n    /// @notice Get dominant trait names for an agent\n    /// @param tokenId Agent to analyze\n    /// @return dominantTraits Array of dominant trait names\n    function _getDominantTraitNames(uint256 tokenId) internal view returns (string[] memory dominantTraits) {\n        PersonalityTraits memory personality = agentPersonalities[tokenId];\n        dominantTraits = new string[](3);\n        \n        // Find top 3 traits\n        uint8[6] memory values = [\n            personality.creativity,\n            personality.analytical,\n            personality.empathy,\n            personality.intuition,\n            personality.resilience,\n            personality.curiosity\n        ];\n        string[6] memory names = [\"creativity\", \"analytical\", \"empathy\", \"intuition\", \"resilience\", \"curiosity\"];\n        \n        // Simple sorting for top 3\n        for (uint256 i = 0; i < 3; i++) {\n            uint256 maxIndex = 0;\n            for (uint256 j = 1; j < 6; j++) {\n                if (values[j] > values[maxIndex]) {\n                    maxIndex = j;\n                }\n            }\n            dominantTraits[i] = names[maxIndex];\n            values[maxIndex] = 0; // Remove from next iteration\n        }\n    }\n    \n    /// @notice Check personality milestones after evolution\n    /// @param tokenId Agent to check\n    /// @param oldPersonality Previous personality state\n    /// @param newPersonality New personality state\n    function _checkPersonalityMilestones(\n        uint256 tokenId,\n        PersonalityTraits memory oldPersonality,\n        PersonalityTraits memory newPersonality\n    ) internal {\n        // Check empathy master milestone\n        if (oldPersonality.empathy < 85 && newPersonality.empathy >= 85) {\n            _unlockMilestone(tokenId, \"empathy_master\", newPersonality.empathy);\n        }\n        \n        // Check creative genius milestone\n        if (oldPersonality.creativity < 90 && newPersonality.creativity >= 90) {\n            _unlockMilestone(tokenId, \"creative_genius\", newPersonality.creativity);\n        }\n        \n        // Check logic lord milestone\n        if (oldPersonality.analytical < 90 && newPersonality.analytical >= 90) {\n            _unlockMilestone(tokenId, \"logic_lord\", newPersonality.analytical);\n        }\n        \n        // Check spiritual guide milestone\n        if (oldPersonality.intuition < 90 && newPersonality.intuition >= 90) {\n            _unlockMilestone(tokenId, \"spiritual_guide\", newPersonality.intuition);\n        }\n        \n        // Check balanced soul milestone (all traits > 60)\n        bool isBalanced = newPersonality.creativity > 60 &&\n                         newPersonality.analytical > 60 &&\n                         newPersonality.empathy > 60 &&\n                         newPersonality.intuition > 60 &&\n                         newPersonality.resilience > 60 &&\n                         newPersonality.curiosity > 60;\n        \n        if (isBalanced && !milestones[tokenId][\"balanced_soul\"].achieved) {\n            _unlockMilestone(tokenId, \"balanced_soul\", 60);\n        }\n    }\n    \n    /// @notice Unlock a personality milestone\n    /// @param tokenId Agent unlocking milestone\n    /// @param milestone Milestone name\n    /// @param traitValue Associated trait value\n    function _unlockMilestone(uint256 tokenId, string memory milestone, uint8 traitValue) internal {\n        milestones[tokenId][milestone] = MilestoneData({\n            achieved: true,\n            achievedAt: block.timestamp,\n            traitValue: traitValue\n        });\n        \n        agents[tokenId].achievedMilestones.push(milestone);\n        \n        emit PersonalityMilestone(tokenId, milestone, traitValue, \"\");\n        emit MilestoneUnlocked(tokenId, milestone, traitValue);\n    }\n    \n\n    \n    // Missing interface functions\n    \n    /// @notice Get personality evolution statistics\n    /// @param tokenId Agent to analyze\n    /// @return totalEvolutions Number of personality changes\n    /// @return evolutionRate Rate of personality change\n    /// @return lastEvolution Timestamp of last evolution\n    function getEvolutionStats(uint256 tokenId) \n        external view override returns (\n            uint256 totalEvolutions,\n            uint256 evolutionRate,\n            uint256 lastEvolution\n        ) {\n        require(agents[tokenId].owner != address(0), \"Agent does not exist\");\n        \n        totalEvolutions = agents[tokenId].totalEvolutions;\n        lastEvolution = agents[tokenId].lastEvolutionDate;\n        \n        // Calculate evolution rate (evolutions per day)\n        if (block.timestamp > agents[tokenId].createdAt) {\n            uint256 daysSinceCreation = (block.timestamp - agents[tokenId].createdAt) / 1 days;\n            evolutionRate = daysSinceCreation > 0 ? (totalEvolutions * 100) / daysSinceCreation : 0;\n        } else {\n            evolutionRate = 0;\n        }\n    }\n    \n\n    \n    /// @notice Check if agent has reached specific personality milestone\n    /// @param tokenId Agent to check\n    /// @param milestone Milestone to check\n    /// @return achieved True if milestone has been achieved\n    /// @return achievedAt Timestamp when milestone was achieved\n    function hasMilestone(uint256 tokenId, string calldata milestone) \n        external view override returns (bool achieved, uint256 achievedAt) {\n        MilestoneData memory m = milestones[tokenId][milestone];\n        return (m.achieved, m.achievedAt);\n    }\n    \n\n    \n    /// @notice Get trait value by name\n    /// @param tokenId Agent ID\n    /// @param traitName Trait name\n    /// @return value Trait value\n    function _getTraitValue(uint256 tokenId, string memory traitName) internal view returns (uint8 value) {\n        PersonalityTraits memory traits = agentPersonalities[tokenId];\n        \n        if (keccak256(bytes(traitName)) == keccak256(bytes(\"creativity\"))) return traits.creativity;\n        if (keccak256(bytes(traitName)) == keccak256(bytes(\"analytical\"))) return traits.analytical;\n        if (keccak256(bytes(traitName)) == keccak256(bytes(\"empathy\"))) return traits.empathy;\n        if (keccak256(bytes(traitName)) == keccak256(bytes(\"intuition\"))) return traits.intuition;\n        if (keccak256(bytes(traitName)) == keccak256(bytes(\"resilience\"))) return traits.resilience;\n        if (keccak256(bytes(traitName)) == keccak256(bytes(\"curiosity\"))) return traits.curiosity;\n        \n        return 0; // Invalid trait name\n    }\n    \n    // ERC-7857 standard functions (simplified for personality preservation)\n    \n    /// @notice Transfer agent with personality preservation\n    /// @param to New owner address\n    /// @param tokenId Agent to transfer\n    function transfer(address to, uint256 tokenId, bytes[] calldata /* proofs */) external override onlyOwnerOrAdmin(tokenId) {\n        require(to != address(0), \"Cannot transfer to zero address\");\n        require(ownerToTokenId[to] == 0, \"Recipient already has an agent\");\n        \n        address from = agents[tokenId].owner;\n        \n        // Update owner mappings\n        ownerToTokenId[from] = 0; // Remove from old owner\n        ownerToTokenId[to] = tokenId; // Add to new owner\n        \n        agents[tokenId].owner = to;\n        agents[tokenId].lastUpdated = block.timestamp;\n        \n        emit Transferred(tokenId, from, to);\n    }\n    \n\n    \n    // Standard ERC-7857 functions\n    function ownerOf(uint256 tokenId) external view override returns (address) {\n        return agents[tokenId].owner;\n    }\n    \n    function authorizedUsersOf(uint256 tokenId) external view override returns (address[] memory) {\n        return agents[tokenId].authorizedUsers;\n    }\n    \n    function authorizeUsage(uint256 tokenId, address user) external override onlyOwnerOrAdmin(tokenId) {\n        require(user != address(0), \"Cannot authorize zero address\");\n        \n        agents[tokenId].authorizedUsers.push(user);\n        emit AuthorizedUsage(tokenId, user);\n    }\n    \n\n    \n\n    \n    \n\n    \n    // Missing ERC-7857 and NFT standard functions\n    \n    /// @notice Get total supply of agents\n    /// @return Total number of minted agents\n    function totalSupply() external view returns (uint256) {\n        return totalAgents;\n    }\n    \n    /// @notice Get balance of owner (0 or 1 due to one agent limit)\n    /// @param owner Address to check\n    /// @return Number of agents owned (0 or 1)\n    function balanceOf(address owner) external view returns (uint256) {\n        require(owner != address(0), \"Invalid address\");\n        return ownerToTokenId[owner] > 0 ? 1 : 0;\n    }\n    \n\n    \n    /// @notice Check if contract supports interface\n    /// @param interfaceId Interface identifier\n    /// @return True if supported\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == 0x01ffc9a7 || // ERC165\n               interfaceId == 0x80ac58cd || // ERC721\n               interfaceId == 0x5b5e139f || // ERC721Metadata\n               super.supportsInterface(interfaceId); // AccessControl interfaces\n    }\n    \n    /// @notice Get agent's creation timestamp\n    /// @param tokenId Agent to query\n    /// @return Creation timestamp\n    function getCreationTime(uint256 tokenId) external view returns (uint256) {\n        return agents[tokenId].createdAt;\n    }\n    \n    /// @notice Get agent's name\n    /// @param tokenId Agent to query\n    /// @return Agent name\n    function getAgentName(uint256 tokenId) external view returns (string memory) {\n        return agents[tokenId].agentName;\n    }\n    \n    /// @notice Get owner's agent token ID\n    /// @param owner Address to check\n    /// @return tokenId Agent token ID (0 if no agent)\n    function getOwnerTokenId(address owner) external view returns (uint256) {\n        return ownerToTokenId[owner];\n    }\n    \n    /// @notice Get caller's agent token ID\n    /// @return tokenId Agent token ID (0 if no agent)\n    function getUserTokenId() external view returns (uint256) {\n        return ownerToTokenId[msg.sender];\n    }\n    \n    /// @notice Complete agent information structure\n    struct AgentInfo {\n        uint256 tokenId;\n        address owner;\n        string agentName;\n        uint256 createdAt;\n        uint256 lastUpdated;\n        uint256 intelligenceLevel;\n        uint256 dreamCount;\n        uint256 conversationCount;\n        bool personalityInitialized;\n        uint256 totalEvolutions;\n        uint256 lastEvolutionDate;\n        PersonalityTraits personality;\n    }\n    \n    /// @notice Get complete agent information by token ID\n    /// @param tokenId Agent to query\n    /// @return info Complete agent information\n    function getAgentInfo(uint256 tokenId) external view returns (AgentInfo memory info) {\n        require(agents[tokenId].owner != address(0), \"Agent does not exist\");\n        \n        DreamAgent memory agent = agents[tokenId];\n        PersonalityTraits memory personality = agentPersonalities[tokenId];\n        \n        info = AgentInfo({\n            tokenId: tokenId,\n            owner: agent.owner,\n            agentName: agent.agentName,\n            createdAt: agent.createdAt,\n            lastUpdated: agent.lastUpdated,\n            intelligenceLevel: agent.intelligenceLevel,\n            dreamCount: agent.dreamCount,\n            conversationCount: agent.conversationCount,\n            personalityInitialized: agent.personalityInitialized,\n            totalEvolutions: agent.totalEvolutions,\n            lastEvolutionDate: agent.lastEvolutionDate,\n            personality: personality\n        });\n    }\n    \n    /// @notice Get owner's agent complete information\n    /// @param owner Address to check\n    /// @return info Complete agent information (or empty if no agent)\n    function getOwnerAgent(address owner) external view returns (AgentInfo memory info) {\n        uint256 tokenId = ownerToTokenId[owner];\n        if (tokenId == 0) {\n            // Return empty struct if no agent\n            return AgentInfo({\n                tokenId: 0,\n                owner: address(0),\n                agentName: \"\",\n                createdAt: 0,\n                lastUpdated: 0,\n                intelligenceLevel: 0,\n                dreamCount: 0,\n                conversationCount: 0,\n                personalityInitialized: false,\n                totalEvolutions: 0,\n                lastEvolutionDate: 0,\n                personality: PersonalityTraits({\n                    creativity: 0,\n                    analytical: 0,\n                    empathy: 0,\n                    intuition: 0,\n                    resilience: 0,\n                    curiosity: 0,\n                    dominantMood: \"\",\n                    lastDreamDate: 0\n                })\n            });\n        }\n        \n        return this.getAgentInfo(tokenId);\n    }\n    \n    /// @notice Get caller's agent complete information\n    /// @return info Complete agent information (or empty if no agent)\n    function getUserAgent() external view returns (AgentInfo memory info) {\n        return this.getOwnerAgent(msg.sender);\n    }\n    \n    // Emergency controls\n    \n    /// @notice Pause contract operations\n    /// @dev Only accounts with PAUSER_ROLE can pause\n    function pause() external onlyRole(PAUSER_ROLE) {\n        _pause();\n    }\n    \n    /// @notice Unpause contract operations\n    /// @dev Only accounts with PAUSER_ROLE can unpause\n    function unpause() external onlyRole(PAUSER_ROLE) {\n        _unpause();\n    }\n    \n    /// @notice Emergency admin function to authorize user\n    /// @param tokenId Agent to authorize user for\n    /// @param user User to authorize\n    /// @dev Only ADMIN_ROLE can use this in emergencies\n    function emergencyAuthorizeUser(uint256 tokenId, address user) external onlyRole(ADMIN_ROLE) {\n        require(user != address(0), \"Cannot authorize zero address\");\n        agents[tokenId].authorizedUsers.push(user);\n        emit AuthorizedUsage(tokenId, user);\n    }\n    \n    /// @notice Emergency admin function to transfer agent\n    /// @param tokenId Agent to transfer\n    /// @param to New owner\n    /// @dev Only ADMIN_ROLE can use this in emergencies\n    function emergencyTransfer(uint256 tokenId, address to) external onlyRole(ADMIN_ROLE) {\n        require(to != address(0), \"Cannot transfer to zero address\");\n        require(ownerToTokenId[to] == 0, \"Recipient already has an agent\");\n        \n        address from = agents[tokenId].owner;\n        \n        // Update owner mappings\n        ownerToTokenId[from] = 0; // Remove from old owner\n        ownerToTokenId[to] = tokenId; // Add to new owner\n        \n        agents[tokenId].owner = to;\n        agents[tokenId].lastUpdated = block.timestamp;\n        emit Transferred(tokenId, from, to);\n    }\n    \n    // Helper functions removed to reduce contract size\n    \n    /// @notice Check if user is authorized to use agent\n    /// @param tokenId Agent to check\n    /// @param user User to check\n    /// @return True if user is authorized\n    function _isAuthorizedUser(uint256 tokenId, address user) internal view returns (bool) {\n        address[] memory authorizedUsers = agents[tokenId].authorizedUsers;\n        for (uint256 i = 0; i < authorizedUsers.length; i++) {\n            if (authorizedUsers[i] == user) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n\n    \n    // Base64 encoding removed to reduce contract size\n} "
    },
    "contracts/interfaces/IERC7857.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nimport \"./IERC7857DataVerifier.sol\";\n\ninterface IERC7857 {\n    /// @dev This emits when a new functional NFT is minted\n    event Minted(\n        uint256 indexed _tokenId,\n        address indexed _creator,\n        address indexed _owner,\n        bytes32[] _dataHashes,\n        string[] _dataDescriptions\n    );\n\n    /// @dev This emits when a user is authorized to use the data\n    event AuthorizedUsage(uint256 indexed _tokenId, address indexed _user);\n\n    /// @dev This emits when data is transferred with ownership\n    event Transferred(\n        uint256 _tokenId,\n        address indexed _from,\n        address indexed _to\n    );\n\n    /// @dev This emits when data is cloned\n    event Cloned(\n        uint256 indexed _tokenId,\n        uint256 indexed _newTokenId,\n        address _from,\n        address _to\n    );\n\n    /// @dev This emits when a sealed key is published\n    event PublishedSealedKey(\n        address indexed _to,\n        uint256 indexed _tokenId,\n        bytes16[] _sealedKeys\n    );\n\n    /// @notice The verifier interface that this NFT uses\n    /// @return The address of the verifier contract\n    function verifier() external view returns (IERC7857DataVerifier);\n\n\n\n    /// @notice Transfer data with ownership\n    /// @param _to Address to transfer data to\n    /// @param _tokenId The token to transfer data for\n    /// @param _proofs Proofs of data available for _to\n    function transfer(\n        address _to,\n        uint256 _tokenId,\n        bytes[] calldata _proofs\n    ) external;\n\n\n\n\n\n\n\n    /// @notice Add authorized user to group\n    /// @param _tokenId The token to add to group\n    function authorizeUsage(uint256 _tokenId, address _user) external;\n\n    /// @notice Get token owner\n    /// @param _tokenId The token identifier\n    /// @return The current owner of the token\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Get the authorized users of a token\n    /// @param _tokenId The token identifier\n    /// @return The current authorized users of the token\n    function authorizedUsersOf(\n        uint256 _tokenId\n    ) external view returns (address[] memory);\n} "
    },
    "contracts/interfaces/IERC7857DataVerifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.20;\n\nstruct PreimageProofOutput {\n    bytes32 dataHash;\n    bool isValid;\n}\n\nstruct TransferValidityProofOutput {\n    bytes32 oldDataHash;\n    bytes32 newDataHash;\n    bytes pubKey;\n    bytes16 sealedKey;\n    bool isValid;\n}\n\ninterface IERC7857DataVerifier {\n    /// @notice Verify preimage of data\n    /// @param proofs Proof of data ownership\n    /// @return Output of the preimage proof verification\n    function verifyPreimage(\n        bytes[] calldata proofs\n    ) external view returns (PreimageProofOutput[] memory);\n\n    /// @notice Verify data transfer validity\n    /// @param proofs Proof of data transfer validity\n    /// @return Output of the transfer validity proof verification\n    function verifyTransferValidity(\n        bytes[] calldata proofs\n    ) external view returns (TransferValidityProofOutput[] memory);\n} "
    },
    "contracts/interfaces/IPersonalityEvolution.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title IPersonalityEvolution - Interface for agent personality evolution\n/// @notice Defines the personality evolution system for Dreamscape iNFTs\n/// @dev Implements personality trait development based on dream analysis\ninterface IPersonalityEvolution {\n    \n    /// @notice Core personality traits structure\n    /// @dev All traits range from 0-100, dominantMood is current emotional state\n    struct PersonalityTraits {\n        uint8 creativity;      // 0-100: Innovation, imagination, artistic thinking\n        uint8 analytical;      // 0-100: Logic, problem-solving, systematic thinking  \n        uint8 empathy;         // 0-100: Emotional understanding, compassion, support\n        uint8 intuition;       // 0-100: Gut feelings, spiritual insights, wisdom\n        uint8 resilience;      // 0-100: Stress handling, recovery, perseverance\n        uint8 curiosity;       // 0-100: Learning desire, exploration, questioning\n        string dominantMood;   // Current emotional state: \"peaceful\", \"anxious\", \"excited\", etc.\n        uint256 lastDreamDate; // Timestamp of last dream processing (prevents multiple per day)\n    }\n    \n    /// @notice Personality impact from dream analysis\n    /// @dev Defines how a dream affects personality traits\n    struct PersonalityImpact {\n        int8 creativityChange;     // -10 to +10 change in creativity\n        int8 analyticalChange;     // -10 to +10 change in analytical thinking\n        int8 empathyChange;        // -10 to +10 change in empathy\n        int8 intuitionChange;      // -10 to +10 change in intuition\n        int8 resilienceChange;     // -10 to +10 change in resilience\n        int8 curiosityChange;      // -10 to +10 change in curiosity\n        string moodShift;          // New dominant mood\n        uint8 evolutionWeight;     // 1-100: How much this dream affects personality\n    }\n    \n    /// @notice Conversation context type for memory management\n    enum ContextType {\n        DREAM_DISCUSSION,    // Discussing previous dreams\n        GENERAL_CHAT,        // General conversation\n        PERSONALITY_QUERY,   // Asking about personality/traits\n        THERAPEUTIC,         // Therapeutic conversation\n        ADVICE_SEEKING      // Seeking advice/guidance\n    }\n    \n    // Events\n    \n    /// @dev Emitted when agent personality evolves from dream processing\n    event PersonalityEvolved(\n        uint256 indexed tokenId,\n        bytes32 indexed dreamHash,\n        PersonalityTraits newPersonality,\n        PersonalityImpact impact\n    );\n    \n    /// @dev Emitted when agent has a conversation (without personality evolution)\n    event AgentConversation(\n        uint256 indexed tokenId,\n        bytes32 indexed conversationHash,\n        ContextType contextType,\n        uint256 conversationCount\n    );\n    \n    /// @dev Emitted when agent reaches personality milestones\n    event PersonalityMilestone(\n        uint256 indexed tokenId,\n        string milestone,\n        uint8 traitValue,\n        string traitName\n    );\n    \n    /// @dev Emitted when agent's response style evolves\n    event ResponseStyleEvolved(\n        uint256 indexed tokenId,\n        string newStyle,\n        string[] dominantTraits\n    );\n    \n    // Core Functions\n    \n    /// @notice Process daily dream and evolve agent personality\n    /// @param tokenId Agent to evolve\n    /// @param dreamHash 0G Storage hash of encrypted dream data\n    /// @param dreamAnalysisHash 0G Storage hash of AI analysis\n    /// @param impact Personality changes from dream analysis\n    function processDailyDream(\n        uint256 tokenId,\n        bytes32 dreamHash,\n        bytes32 dreamAnalysisHash,\n        PersonalityImpact calldata impact\n    ) external;\n    \n    /// @notice Record conversation without personality evolution\n    /// @param tokenId Agent having conversation\n    /// @param conversationHash 0G Storage hash of conversation data\n    /// @param contextType Type of conversation for context building\n    function recordConversation(\n        uint256 tokenId,\n        bytes32 conversationHash,\n        ContextType contextType\n    ) external;\n    \n    /// @notice Get agent's current personality traits\n    /// @param tokenId Agent to query\n    /// @return traits Current personality traits\n    function getPersonalityTraits(uint256 tokenId) \n        external view returns (PersonalityTraits memory traits);\n    \n    /// @notice Get agent's dream history hashes\n    /// @param tokenId Agent to query\n    /// @param limit Maximum number of dreams to return (0 = all)\n    /// @return dreamHashes Array of dream storage hashes\n    function getDreamHistory(uint256 tokenId, uint256 limit) \n        external view returns (bytes32[] memory dreamHashes);\n    \n    /// @notice Get agent's conversation history hashes\n    /// @param tokenId Agent to query\n    /// @param limit Maximum number of conversations to return (0 = all)\n    /// @return conversationHashes Array of conversation storage hashes\n    function getConversationHistory(uint256 tokenId, uint256 limit) \n        external view returns (bytes32[] memory conversationHashes);\n    \n    /// @notice Check if agent can process dream today (24h cooldown)\n    /// @param tokenId Agent to check\n    /// @return canProcess True if agent can process a dream today\n    function canProcessDreamToday(uint256 tokenId) \n        external view returns (bool canProcess);\n    \n\n    \n\n    \n\n    \n    // Advanced Analytics\n    \n    /// @notice Get personality evolution statistics\n    /// @param tokenId Agent to analyze\n    /// @return totalEvolutions Number of personality changes\n    /// @return evolutionRate Rate of personality change\n    /// @return lastEvolution Timestamp of last evolution\n    function getEvolutionStats(uint256 tokenId) \n        external view returns (\n            uint256 totalEvolutions,\n            uint256 evolutionRate,\n            uint256 lastEvolution\n        );\n    \n\n    \n    /// @notice Check if agent has reached specific personality milestone\n    /// @param tokenId Agent to check\n    /// @param milestone Milestone to check (\"empathy_master\", \"creative_genius\", etc.)\n    /// @return achieved True if milestone has been achieved\n    /// @return achievedAt Timestamp when milestone was achieved (0 if not achieved)\n    function hasMilestone(uint256 tokenId, string calldata milestone) \n        external view returns (bool achieved, uint256 achievedAt);\n    \n    // Batch Operations\n    \n\n} "
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}